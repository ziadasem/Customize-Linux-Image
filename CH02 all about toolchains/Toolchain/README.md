# Toolchains
in this chapter, an explanation of toolchains will be introduced in addition to working examples to generate a toolchain for `Qemu` (an emulator) and `BeagleBone Black`.

- [Toolchains](#toolchains)
  - [1. Introduction](#1-introduction)
    - [1.1 Toolchain components](#11-toolchain-components)
    - [1.2 Target of a toolchain](#12-target-of-a-toolchain)
    - [1.3 CPU architectures and toolchain names](#13-cpu-architectures-and-toolchain-names)
    - [1.4 The C-library](#14-the-c-library)
      - [Choosing C libraries](#choosing-c-libraries)
  - [2. Finding a toolchain](#2-finding-a-toolchain)
    - [2.1 Pre-built toolchains](#21-pre-built-toolchains)
    - [2.2 Customized toolchains](#22-customized-toolchains)
  - [3. Building a toolchain using crosstool-NG](#3-building-a-toolchain-using-crosstool-ng)
    - [3.1 The Story of crosstool and crosstool-NG](#31-the-story-of-crosstool-and-crosstool-ng)
    - [3.2 Downloading and Installing crosstool-NG](#32-downloading-and-installing-crosstool-ng)
    - [3.3 Building a toolchain for BeagleBone Black](#33-building-a-toolchain-for-beaglebone-black)
    - [3.4 Building a toolchain for Qemu](#34-building-a-toolchain-for-qemu)
  - [4. Anatomy of a toolchain](#4-anatomy-of-a-toolchain)
    - [4.1 Test the generated toolchain](#41-test-the-generated-toolchain)
    - [4.2 Find out about the compiler](#42-find-out-about-the-compiler)
    - [4.3 The sysroot, library, and header files](#43-the-sysroot-library-and-header-files)
    - [4.4 Other tools in the toolchain](#44-other-tools-in-the-toolchain)
    - [4.5 Components of the C library](#45-components-of-the-c-library)
  - [5. Static and Shared Libraries and linking with them](#5-static-and-shared-libraries-and-linking-with-them)
    - [5.1 Static Libraries](#51-static-libraries)
      - [When to use the static library](#when-to-use-the-static-library)
      - [Compile against a static library](#compile-against-a-static-library)
      - [Create a static library](#create-a-static-library)
    - [5.2 Shared/Dynamic Libraries](#52-shareddynamic-libraries)
      - [Linking to shared library](#linking-to-shared-library)
      - [Load a shared library](#load-a-shared-library)
      - [Understanding shared library version numbers](#understanding-shared-library-version-numbers)
  - [6. The art of cross-compiling](#6-the-art-of-cross-compiling)
    - [6.1 Makefiles](#61-makefiles)
    - [6.2 Autotools](#62-autotools)
      - [An example – SQLite](#an-example-sqlite)
    - [6.3 Autotools; Package configuration](#63-autotools-package-configuration)
    - [6.4 Problems with cross-compiling](#64-problems-with-cross-compiling)
    - [6.5 CMake](#65-cmake)
      - [CMake with libraries](#cmake-with-libraries)

  - [7. Additional Information](#7-additional-information)
    - [7.1- POSIX](#71-posix)
    - [7.2 -API and interfaces](#72-api-and-interfaces)
    - [7.3- Application binary interface](#73-application-binary-interface)

**Why is toolchain important for an Embedded Linux project**

For an Embedded Linux project, The toolchain is the first element of embedded Linux and the starting point of the project. it will use be to compile all the other elements of the embedded Linux system on the target device which are:
* Bootloader
* Kernel
* RFS

The choices of toolchains at this early will have a profound impact on the final outcome. Since a toolchain should be:
* capable of making effective use of the target hardware by using the **optimum instruction set** for the target processor
* It should support the languages that the target requires
* have a solid implementation of the Portable Operating System Interface (POSIX) and other system interfaces, hint you can read more about POSIX in the [Additional Information](#7-additional-information) section

to get a toolchain, there are different methods some of them are:
* get a prebuilt toolchain, either by downloading and installing it, or probably inside the Board Support Package shipped with the target hardware platform by the vendor
The drawback is that you don't have flexibility on your toolchain features (which C library? hard-float or soft-float? Which ABI?)
* building from the source (e.g. use the `Cross-Tool NG` tool)
* use a toolchain generated by a buildsystem which will be discussed later (e.g. use `yocto` to generate a toolchain)


While this chapter primarily focuses on employing the second method for creating a toolchain, it also includes a segment discussing the downloading of prebuilt toolchains.

**Before Getting Start**

it is required to use A Linux-based host system (e.g. Ubuntu) with *autoconf, automake, bison, bzip2, cmake, flex, g++, gawk, gcc, gettext, git, gperf, help2man, libncurses5-dev, libstdc++6, libtool, libtool-bin, make, patch, python3-dev,rsync, texinfo, unzip, wget, and xz-utils* or their equivalents installed.

if you have Ubuntu (or any other distribution that uses apt package manager) execute the following command:
```bash
sudo apt-get install autoconf automake bison bzip2 cmake  flex g++ gawk gcc gettext git gperf help2man libncurses5-dev libstdc++6 libtool libtool-bin make patch python3-dev rsync texinfo unzip wget xz-utils
```

if you don't have the beaglebone black you can use the Qemu emulator

## 1. Introduction
 toolchain is a set of distinct software development tools that are linked (or chained) together by specific stages such as GCC, binutils, and glibc. Optionally, a toolchain may contain other tools such as a debugger or a compiler for a specific programming language, such as C++.<br>

**Versions of Toolchains**

* GNU toolchain

    The most used toolchain for Linux, and has the advantage of compatibility with the existing code base and support for a wide range of architectures and operating systems

* Clang compiler and the associated Low Level Virtual Machine (LLVM) project

    over the past few years, have progressed to the point that it is now a viable alternative to a GNU toolchain One major distinction between LLVM and GNU-based toolchains is the licensing; LLVM has a BSD license while GNU has the GPL. it is also faster than GNU in compilation and better diagnostics

### 1.1 Toolchain components
![toolchainblock diagram](https://i.ibb.co/Lzm3wrS/toolchain.jpg)


a standard toolchain consists of the following:

1- **Binutils**<br>
GNU Binutils is the first component of a toolchain. The GNU Binutils contains two very important tools:


* `as`, the assembler, that turns assembly code (generated by GCC) into binary
* `ld`, the linker, that links several object codes into a library, or an executable (discussed in the prerequisites chapter)

Binutils also contains a couple of other binary file manipulation or analysis tools, such as `objcopy`, `objdump`, `nm`, `readelf`, `strip`, and so on. The Binutils [website](https://sourceware.org/binutils/docs-2.19/) has some documentation on all these tools. 

2- **Compilers**<br>
in GNU toolchains we have GNU Compiler Collection (GCC), which are the compilers for C and other languages, which, depending on the version of GCC, include 
* C++
* Objective-C,
* Objective-C++
* Java
* Fortran
* Ada
* Go

They all use a common backend (the phases of the compiler that  that produces assembler code), which is fed to the GNU assembler.

3- **C library**

C library implements the standardized application program interface (API) POSIX specification, which is the main interface to the operating system and provides higher-level services. (see additional information section for more about API and interfaces [additional information](#7-additional-information)), it will be discussed further in this section.


* glibc 

    GNU C-Library is the C library from the GNU project. It's the C library used by virtually all desktop and server GNU/Linux systems. It's feature-full, portable, and complies to standards, but a bit bloated

    * Embedded GLIBC (EGLIBC)

        It is a variant of the GNU C Library (GLIBC) optimized for embedded systems. Its goals include reduced footprint and support for cross-compiling and cross-testing while maintaining source and binary compatibility with GLIBC. The project is discontinued.

* uClibc

    microcontroller C library is an alternate C library, which as its name suggests features a much smaller footprint. This library can be an interesting alternative if flash space and/or memory footprint are an issue. However, the space advantages gained using uClibc are becoming less important as the price of memory and flash continues to drop. It is still a useful C library for embedded systems without an MMU.

    * uClibc-ng 

         a spin-off/fork of the uClibc C library. The main goal of the spin-off is to do regular releases and do a lot of automatic runtime testing.

* musl

    New standard C library. musl is lightweight, fast, simple, free, and strives to be correct in the sense of standards-conformance and safety.

The C library has a special relation with the C compiler, so the choice of the C library must be made when the toolchain is generated. Once the toolchain has been built, it is no longer possible to switch to another library. 

4- **Debugger**

Most people would consider the GNU Debugger (GDB) to be part of the toolchain as well, In the embedded Linux world, the typical debugger is GDB. 

5- **Linux Kernel Headers**
    
Kernel headers are necessary for the C Library to compile functions that directly access the kernel. The usage of kernel headers extends beyond the C library; certain programs that interact directly with the kernel also require inclusion of kernel headers, such as those involved in drawing graphics on Linux frame buffers.

> Note: Linux kernel headers are version-specific. For instance, if a program is compiled against kernel version 4.19, it may not function properly on newer kernel versions like 6.6, but it should be compatible with older kernel versions due to backward compatibility support

### 1.2 Target of a toolchain
as mentioned toolchains take the program code as input and translate it to equivalent assembly code which depends on the processor. This produced code will most likely depend on various calls to the operating system (e.g. to allocate dynamic memory), and have a header defining properties of the assembly file (e.g. the location of the code and data sections) (e.g. ELF, PE). An assembler then compiles this assembly to object files, which are linked using the linker of this platform. Hence All these tools produce code for a specific architecture and OS.

so a toolchain is specified towards a specific target which mainly depends on the processor architecture and the host operating system. hence if a developer builds an application with the toolchain on his machine (for example Linux on x86_64), if he tries to move this program to a different system (e.g. Windows on x86_64), the program will not work as it was linked via Linux Linker against Linux defined system call which isn't the same as windows. the same result will happen if the developer moves the program from Linux on x86_64 to Linux on arm64 (Raspberry Pi for example). 

This does not mean that the compiler and linker cannot run on another type of system. The process of compiling code for another system is called cross-compiling. Then we have two types of toolchains:

**Types of toolchains**

* Native: 

    This toolchain runs on a system to generate programs for the same type of system that it runs on (e.g. compiling a program on Linux to run on the same machine). This is the usual case for desktops and servers, and it is becoming popular on certain classes of embedded devices. The Raspberry Pi running Debian for ARM, for example, has self-hosted native compilers

* Cross:

    This toolchain runs on a different type of system than the target, where it runs on a system to output an executable for another target (hence its name cross) allowing the development to be done on a fast desktop PC and then loaded onto the embedded target for testing and running (e.g. compiling a program on Linux on x86_64 to run on raspberry pi)

Almost all embedded Linux development is done using a cross-development toolchain, partly because most embedded devices are not well suited to program development since they lack computing power, memory, and storage, but also because it keeps the host and target environments separate. to imply the principle of keeping the toolchain for the target consistent throughout the life of the project.

**what if the target and the host have the same architecture and OS, x86_64 Linux, for example?**

In this case, the native toolchain on the host can build an executable that can be executed on the host and on the target, however, This works up to a point until the host distribution will receive updates more often than the target, or that different engineers building code for the target will have slightly different versions of the host development libraries.

Over time, as this sperate continues changing the development and target systems will not be the same, and the principle that the toolchain should remain constant throughout the life of the project will be violated. 
This approach can work if the host and the target build environments are in lockstep with each other. However, a much better approach is to keep the host and the target separate, and a cross-toolchain is the way to do that.

However, cross-development is not always simple because many open-source packages are not designed to be built in this way. hence in case of compiling a large number of additional packages, it is better to natively compile them. For example, building a Debian distribution for the Raspberry Pi or BeagleBone using a cross-compiler would be very hard. Instead, they are natively compiled.


### 1.3 CPU architectures and toolchain names

the toolchain has to be built according to the all capabilities of the target CPU not only the CPU architecture os the following points are the capabilities of a CPU that a toolchain has to be built according to:

• **CPU architecture**: ARM, Microprocessor without Interlocked Pipelined Stages (MIPS), x86_64, and so on

• **Big- or little-endian operation**: Some CPUs can operate in both modes, but the machine code is different for each

• **Floating point support**: Not all versions of embedded processors implement a hardware floating-point unit, in which case the toolchain has to be configured to call a software floating-point library instead

• **Application Binary Interface (ABI)**: The calling convention used for passing parameters between function calls at the binary level and (see [ABI](#73-application-binary-interface) in the additional information section) 

With many architectures, the ABI is constant across the family of processors. One notable exception is ARM. The ARM architecture transitioned to the Extended Application Binary Interface (EABI) in the late 2000s, resulting in the previous ABI being named the Old Application Binary Interface (OABI).

While the OABI is now obsolete, you'll continue to see references to EABI. Since then, the EABI has split into two, based on the way the floating-point parameters are passed:
* The original EABI uses general-purpose (integer) registers 
* the newer Extended Application Binary Interface Hard-Float (EABIHF) uses a floating point register

The *EABIHF* is significantly faster at floating-point operations since it removes the need for copying between integer and floating-point registers, but it is not compatible with CPUs that do not have a floating-point unit. The choice, then, is between two incompatible ABIs; you cannot mix and match the two, and so you have to decide at this stage.

**GNU Tools name in GNU Toolchain**

GNU uses prefixes for every tool, so it can give information about which target(OS and architecture) this toolchain compiles for. this prefix consists of 3 or 4 parts separated by dashes indicating the CPU architecture Vendor, OS, and ABI.
```
<arch>-<vendor>-<OS>-<abi>
```
to get the the toolchain tool name without navigating to its directory execute the following command:
```bash
gcc --dumpmachine
```
on Linux, the result is:
```bash
x86_64-linux-gnu
```
on Windows, the result is:
```bash
x86_64-w64-mingw32
```
as mentioned before and shown and the name consists of the following parts:
* CPU architecture: `x86_64` on both machines
* vendor: it is optional as in the two cases above, but its value may be buildroot, poky, or just unknown
* Operating System: the kernel of the OS `Linux` and `w64`
* ABI: for Linux is `gnu` and for Windows is MinGW - Minimalist GNU for Windows `mingw32`

a detailed description of ABI is available in the additional information [section below](#73-application-binary-interface). 


### 1.4 The C-library
previously mentioned the available C libraries, in this section the function of a C Library and the criteria for choosing it will be explained.

consider the following example, a simple C program to open a file
```c
#include <stdio.h>
int main() {
 FILE *file;
    char filename[] = "example.txt";
 file = fopen(filename, "r");
    fclose(file);
    return 0;
}
```
a very simple function that is independent of OS, which is responsible for managing files. but how is it possible for this simple function to open a file independent of OS with this simplicity?  the answer is in the C library. The function ` fopen(filename, "r");` is implemented in C-Library to do the process of opening a file in the target OS. 

In this example Linux is used; the request to the Linux kernel to open a file and return it is performed in certain steps with defined inputs and outputs to/from the kernel (see steps in [POSIX](#71-posix) subsection in the additional information section). But if every operating system defines its steps and input/output for such an operation it will be a headache to write a library for every OS to be compatible with.

fortunately, a family of OS implements common standards called the Portable Operating System Interface standards (POSIX standards) such as Linux, Mac, QNX, and others which standardize the steps and process of communication between applications (called user-space) and the kernel (kernel space) via a common system call, all of these new terms will be discussed in another chapter.

![c library block diagram](https://i.ibb.co/4Jqs1JV/Untitled-1.jpg)

from the graph, it is clear that a program can make the system call and request from the kernel directly but it will make the program more complex and reinvent the wheel.
![comic](https://i.ibb.co/B6HGLNp/comic.jpg)

finally, we can say that
> A C Library is **an implementation of interface between programs and kernel**.

it is not only limited to C language, other languages like Java and Python are linked with libraries that use the C library for providing runtime support and calling OS functions. 

different C libraries were mentioned previously, in the following section is a comparison between them and the criteria for choosing them.

#### Choosing C libraries
* **glibc**: it is very big and the most complete implementation of POSIX
* **musl**: a newer and smaller alternative for glibc, used when the target has limited memory
* **uClibc-ng**: it was developed for a Linux distro that can work without MMu (an OS requires MMU), this distro is called microcontroller Linux (uCLinux). until it has been adopted to support full Linux. the ng postfix means a new generation of the original library uClibc which faces issues in its functionality
* **eglibc**: embedded glibc; an optimized version of glibc for microcontroller and added support for some architectures that weren't supported by glibc like PowerPC e500 CPU. however, it is now obsolete and its code is merged back to glibc

now after discussing every library, **it is recommended to use glibc** unless:
* you are using uCLinux, the best choice for it is to use uClibc-ng
* you are using a target with limited resources, the best choice for it is to use musl

> Note: not all pre-built toolchains support all C libraries


## 2. Finding a toolchain

as previously mentioned, methods for getting a toolchain are:
* use pre-built toolchains
* build it with your customization, or use a tool to build it
* use buildsystems to generate one

### 2.1 Pre-built toolchains
for a pre-built toolchain is an easy solution, but here are some considerations you should make:
* does the toolchain support the required C library?
* does the toolchain support the target hardware and processor architecture?
* does the toolchain support the target ABI?
* does the toolchain size fit your requirements?
* Is it updated with the latest security requirements and bug fixes?
* does it contain the latest kernel headers version for Linux?

if your answer is no for any of these you should search for another pre-built toolchain, which is considered a daunting task, especially in customizing Linux for unpopular boards.

however, some entities provide pre-built toolchains like:

* SOC vendors
* A third-party Linux tool vendor
* an alliance dedicated to providing system-level support for a given architecture. For example, Linaro for the ARM architecture
* generated toolchains from build systems such as provided by [yocto](https://downloads.yoctoproject.org/releases/yocto/yocto-5.0.1/toolchain/)

here are some resources from [elinux](https://elinux.org/Toolchains#Prebuilt_toolchains):

1. **Bootlin**<br/>
Since June 2017, Bootlin has been offering free pre-built toolchains on [toolchains.bootlin.com](http://toolchains.bootlin.com/), supporting more than 38 CPU architecture variants, and three C libraries: GNU libc, uClibc-ng, and musl.

2. **CodeSourcery**<br/>
[CodeSourcery](http://www.codesourcery.com/) is used to release free cross-compiling toolchains for the major embedded architectures.

3. **Linaro (ARM)**<br/>
[Linaro](https://wiki.linaro.org/WorkingGroups/ToolChain) releases optimized toolchains for recent ARM CPUs (Cortex A8, A9...). These include Linaro's latest contributions to mainline GCC but backported to stable GCC versions for immediate use by product developers. Linaro hires CodeSourcery people to improve ARM toolchains, so the ARM toolchains that you get with Linaro should be at least as good as the CodeSourcery ones.

 Native toolchains are available through the standard GCC toolchain in Ubuntu. Cross toolchains from Linaro are available to Ubuntu users through special packages:

```bash
sudo add-apt-repository ppa:linaro-maintainers/toolchain
sudo apt-get install gcc-arm-linux-gnueabi
```

Now find out the path and name of the cross-compiler executable by looking at the contents of the package:

 `dpkg -L gcc-arm-linux-gnueabi`

Arch Linux users can install:
```bash
yaourt -S gcc-linaro-arm-linux-gnueabihf
```


4. **musl.cc**<br/>

 [musl.cc](https://musl.cc/) provides static, musl-based cross- and native- GCC toolchains targeting various Linux- and Windows-based platforms. Toolchains run on Linux, macOS, Windows, and Solaris. Please note that this is a community-run website and is not officially endorsed by the musl project or its authors.

[find more](https://elinux.org/Toolchains#Prebuilt_toolchains)


### 2.2 Customized toolchains

toolchains are a series of programs and libraries that can be built, but building a toolchain from scratch is not an easy task. you read about it from [cross Linux from scratch](https://trac.clfs.org/). however, there is a tool that encapsulates make files and scripts for building toolchains and lets the user configure these scripts and make files to customize the output toolchain via a menu interface or by choosing from samples to build a toolchain. this tool is called **Crosstool-ng**. 

## 3. Building a toolchain using crosstool NG
in this section, a toolchain is created for beaglebone black and Qemu. this section may be grouped with other sections from different articles into a separate article that shows the practical steps for customization of an image for Qemu and beaglebone black.

### 3.1 The Story of crosstool and crosstool NG
building, updating, and maintaining a toolchain from scratch is a hard task. for that, on the community of the cross-compiler, the developers are uploading their scripts trying to automate some tasks of building and testing a toolchain. a programmer was responsible for the maintenance of a toolchain in his work and was searching for a solution for automating his process. he collected the scripts and made files from the community and added some advanced features including support for newer versions of toolchains and the ability to automate testing and created a standalone tool that automates the generation of toolchain and he called it the **crosstool**, his name is Dan Kegel you can read about his full story from [here](http://kegel.com/crosstool/).

the crosstool didn't support the generation of all compilers, so in late 2007 Yann E. Morin added the support for uClibc and other features including a menu interface that makes users do the configuration via a menu and called this the new generation of the toolchain, or **crosstool-NG**, read about the full story from [here](https://crosstool-ng.github.io/docs/introduction/) or visit their [website](https://crosstool-ng.github.io/).


### 3.2 Downloading and Installing crosstool NG

before downloading and installing crosstool-NG, you should install the tools stated at the beginning of the section.

1. create a directory for the crosstool-NG
2. fetch the latest version crosstool-NG (at writing of this article it is 1.26.0) 
3. install and config the crosstool-NG

you can get the crosstool-NG as tarball from [here](http://crosstool-ng.org/download/crosstool-ng/) or by using command `wget` as follows:
```bash
wget http://crosstool-ng.org/download/crosstool-ng/crosstool-ng-VERSION.tar.bz2
```
Note: replace the -VERSION with the required version number, as in this case the latest version is 1.26.0, then

```bash
ziad@ziadpc:~$ wget http://crosstool-ng.org/download/crosstool-ng/crosstool-ng-1.26.0.tar.bz2
```

or clone the github repository and checkout to the latest version, note the default branch is the dev branch which is might be unstable. in this chapter this method is used.

```bash
ziad@ziadpc:~$ mkdir toolchain_playground && cd toolchain_playground

ziad@ziadpc:~/toolchain_playground$ git clone https://github.com/crosstool-ng/crosstool-ng.git #download the unstable development branch
ziad@ziadpc:~/toolchain_playground$ cd crosstool-ng
ziad@ziadpc:~/toolchain_playground$ git checkout crosstool-ng-1.26.0 #download the stable release branch
```
for running configuration and installation, navigate to the  execute the following commands from the `crosstool-ng` directory:
```bash
./bootstrap
./configure --prefix=${PWD} --enable-local #run the configure script
make
make install #in case of failure run with sudo make install 
```

The --prefix=${PWD} option means that the program will be installed into the current directory, which avoids the need for root permissions, as would be required if you were to
install it in the default location /usr/local/share.

now crosstool-ng is installed, next we will build toolchain for beaglebone black.

### 3.3 Building a toolchain for BeagleBone Black
for configuration of the toolchain for BeagleBone we can launch the menu to configure the output, however we can use samples to generate the toolchain. 

to list samples
```bash
./ct-ng list-samples
```
example:
```bash
ziad@ziadpc:~/toolchain_playground/crosstool-ng$ ./ct-ng list-samples
Status  Sample name
[L...]   aarch64-ol7u9-linux-gnu
[L...]   aarch64-ol8u6-linux-gnu
[L...]   aarch64-ol8u7-linux-gnu
[L...]   aarch64-rpi3-linux-gnu
[L...]   aarch64-rpi4-linux-gnu
[L...]   aarch64-unknown-linux-gnu
[L...]   aarch64-unknown-linux-uclibc
[L...]   alphaev56-unknown-linux-gnu
....
#the rest of the output is left over
....
 L (Local)       : sample was found in current directory
 G (Global)      : sample was installed with crosstool-NG
 X (EXPERIMENTAL): sample may use EXPERIMENTAL features
 B (BROKEN)      : sample is currently broken
 O (OBSOLETE)    : sample needs to be upgraded

```
for example we can select the configuration of `aarch64-ol7u9-linux-gnu`, to set the configuration execute the following:
```bash
ziad@ziadpc:~/toolchain_playground/crosstool-ng$ ./ct-ng aarch64-ol7u9-linux-gnu

CONF  aarch64-ol7u9-linux-gnu
#
#configuration written to .config
#

***********************************************************

Initially reported by: Jose E. Marchesi
URL: 

Comment:
OL 7.9 toolchain configured for AARCH64

***********************************************************

Now configured for "aarch64-ol7u9-linux-gnu"
ziad@ziadpc:~/toolchain_playground/crosstool-ng$ 
```
now we can launch the menu configuration and see the preconfiured values
```bash
ziad@ziadpc:~/toolchain_playground/crosstool-ng$ ./ct-ng menuconfig
```
![menuconfig](https://i.ibb.co/TL3dXcG/Screenshot-from-2024-06-10-18-22-27.png)

then, we can search for the toolchain configuration sample that fits beaglebone black to save time without manually setting the configuration from the menu.

recalling the name of a toolchain:
```
<arch>-<vendor>-<os>-<abi>
```
after searching about beaglebone black on their website, we will found that it utilizes **AM335x 720MHz ARM Cortex-A8** processor. 
so for architecture: we found that it is ARM. now we will search about its floating point processor.

after searching on ARM website, we found that this processor has a floating point processor.
![arm processor](https://developer.arm.com/-/jssmedia/Arm%20Developer%20Community/Images/Block%20Diagrams/Cortex-A%20Processor/Cortex-A8.png?h=311&iar=0&w=325&rev=d7eb2bd926f24f35b0adf7e96172b39a&hash=FD003080F18279ED87091C45BCA35AFB)

for decding the C-library to use, beaglebone supports booting from SD card, so memory size isn't a problem, hence we can use glibc as the selected library.

now we will search for the configuration that best fit our requirements:

```bash
ziad@ziadpc:~/toolchain_playground/crosstool-ng$ ./ct-ng list-samples | grep arm-cortex
[L...]   arm-cortex_a15-linux-gnueabihf
[L..X]   arm-cortexa5-linux-uclibcgnueabihf
[L...]   arm-cortex_a8-linux-gnueabi
[L..X]   arm-cortexa9_neon-linux-gnueabihf
[L..X]   x86_64-w64-mingw32,arm-cortexa9_neon-linux-gnueabihf
```

the best configuration to fit our requirements is ` arm-cortex_a8-linux-gnueabi`, except its abi not supports hard float (`gnueabi` should be `gnueabiHF`), then here is the power of customization that we can select this sample and modify it via menu configuration to use `gnueabihf`.

**1. Find the complete details about this sample**
```bash
 ./ct-ng show-[sample name]
```
```bash
ziad@ziadpc:~/toolchain_playground/crosstool-ng$ ./ct-ng show-arm-cortex_a8-linux-gnueabi
[L...]   arm-cortex_a8-linux-gnueabi
    Languages       : C,C++
    OS              : linux-6.4
    Binutils        : binutils-2.40
    Compiler        : gcc-13.2.0
    C library       : glibc-2.38
    Debug tools     : duma-2_5_21 gdb-13.2 ltrace-0.7.3 strace-6.4
    Companion libs  : expat-2.5.0 gettext-0.21 gmp-6.2.1 isl-0.26 libelf-0.8.13 libiconv-1.16 mpc-1.2.1 mpfr-4.2.1 ncurses-6.4 zlib-1.2.13 zstd-1.5.5
    Companion tools :
```

**2. Set the sample configuration**

```
./ct-ng arm-cortex_a8-linux-gnueabi
```

```bash
ziad@ziadpc:~/toolchain_playground/crosstool-ng$ ./ct-ng arm-cortex_a8-linux-gnueabi

CONF  arm-cortex_a8-linux-gnueabi
#
#configuration written to .config
#

***********************************************************

Initially reported by: Yann E. MORIN
URL: http://ymorin.is-a-geek.org/

***********************************************************

Now configured for "arm-cortex_a8-linux-gnueabi"
```

**3- Decide which configuration you want to change in the menu config**

1- enable support for hardware floating point

2- use neon as specific FPU **to BUILD THE LINUX KERNEL successfully**

3- enable the toolchain to be linked with new libraries after built

```bash
ziad@ziadpc:~/toolchain_playground/crosstool-ng$ ./ct-ng menuconfig
```

1- enable support for hardware floating point
* navigate to **Target options** (press enter on it)
* in target options navigate to **Floating Point**(press enter on it)
* in floating point menu choose **hardware (FPU)** then press enter

2- use neon as specific FPU 
* in target options menu navigate to **Use specific FPU**
* write **neon** and press enter

3- enable the toolchain to be linked with new libraries after built
* in the main menu navigate to **Paths and misc options** menu
* navigate to **Render the toolchain read-only** and disable it (it shouldn't start with an asterisk)

finally choose save in the bottom menu, then exit.now we can build our beaglebone black toolchain

> NOTE: you can search for settings and their current value  by pressing `/` in the menuconfig

after getting back to the terminal, type the following to build the toolchain.
```bash
./ct-ng build
```

```bash
iad@ziadpc:~/toolchain_playground/crosstool-ng$ ./ct-ng build
[INFO ]  Performing some trivial sanity checks
[WARN ]  Number of open files 1024 may not be sufficient to build the toolchain; increasing to 2048
[INFO ]  Build started 20240610.190437
[INFO ]  Building environment variables
[WARN ]  Directory '/home/ziad/src' does not exist.
[WARN ]  Will not save downloaded tarballs to local storage.
[EXTRA]  Preparing working directories
[EXTRA]  Installing user-supplied crosstool-NG configuration
[EXTRA]  =================================================================
[EXTRA]  Dumping internal crosstool-NG configuration
[EXTRA]    Building a toolchain for:
[EXTRA]      build  = x86_64-pc-linux-gnu
[EXTRA]      host   = x86_64-pc-linux-gnu
[EXTRA]      target = arm-cortex_a8-linux-gnueabihf
[EXTRA]  Dumping internal crosstool-NG configuration: done in 0.39s (at 00:06)
[INFO ]  =================================================================
[INFO ]  Retrieving needed toolchain components' tarballs
[EXTRA]    Retrieving 'linux-6.4'
.....
```

<br>

**THE OUTPUT :**

> **Find the build output in ~/x-tools/arm-cortex_a8-linux-gnueabihf**


### 3.4 Building a toolchain for Qemu
a complete description and installation instructions of qemu is available in the introduction article, here we will build the toolchain for it.

On the QEMU target, you will be emulating an ARM-versatile PB evaluation board that has an ARM926EJ-S processor core, which implements the ARMv5TE instruction set and 32-bit. You need to generate a crosstool-NG toolchain that matches the specification. The procedure is very similar to the one for the BeagleBone Black.

![processor](https://documentation-service.arm.com/static/5e8e3d1088295d1e18d3a97a?token=)

before choosing from samples, we will define some points:

1. which architecture we are building for?; **ARM non 64-bit (choose arm not aarch64)**
2. does the memory size can be a problem?; **No, we can use glibc**
3- does it uses floating point unit?: **No**

hence the toolchain name that fits these requirements is
```bash
arm-linux-gnueabi
or arm-.*-linux-gnueabi #regular expression, no matter who is the vendor
```

```bash
ziad@ziadpc:~/toolchain_playground/crosstool-ng$ ./ct-ng list-samples | grep arm-.*-linux-gnueabi
[L...]   arm-cortex_a15-linux-gnueabihf
[L...]   arm-cortex_a8-linux-gnueabi
[L..X]   arm-cortexa9_neon-linux-gnueabihf
[L..X]   x86_64-w64-mingw32,arm-cortexa9_neon-linux-gnueabihf
[L...]   arm-ol7u9-linux-gnueabi
[L...]   arm-ol7u9-linux-gnueabihf
[L...]   arm-unknown-linux-gnueabi
```

the best search result is `[L...]   arm-unknown-linux-gnueabi`. now for setting this sample as predefined configuration and configure the toolchain to allow libraries to be linked with it after building.

before choosing new toolchain to build, we need to clean the previous build for preventing any potential bugs.
```
./ct-ng  distclean
```
```bash
ziad@ziadpc:~/toolchain_playground/crosstool-ng$ ./ct-ng  distclean
  CLEAN scripts
  CLEAN log
  CLEAN build dir
  CLEAN .config

```

```bash
ziad@ziadpc:~/toolchain_playground/crosstool-ng$ ./ct-ng arm-unknown-linux-gnueabi
  CONF  arm-unknown-linux-gnueabi
#
#No change to .config
#

***********************************************************

Initially reported by: Alexander BIGGA
URL: http://sourceware.org/ml/crossgcc/2008-06/msg00031.html

***********************************************************

Now configured for "arm-unknown-linux-gnueabi"

```

then open menuconfig
```bash
ziad@ziadpc:~/toolchain_playground/crosstool-ng$ ./ct-ng menuconfig
```

then enable the toolchain to be linked with new libraries after built:

* in the main menu navigate to **Paths and misc options** menu
* navigate to **Render the toolchain read-only** and disable it (it shouldn't start with an asterisk)

lastly, build the toolchain.

```bash
ct-ng build
```

## 4. Anatomy of a toolchain
in this section, we will discover the generated files in the toolchain, the generated files in `x-tools/arm-cortex_a8-linux-gnueabihf/` or `x-tools/arm-unknown-linux-gnueabi/` in the case of the toolchain for beaglebone black or Qemu.

### 4.1 Test the generated toolchain

```bash
ziad@ziadpc:~$ cd x-tools/arm-cortex_a8-linux-gnueabihf/
ziad@ziadpc:~/x-tools/arm-cortex_a8-linux-gnueabihf$ ls
total 2.0M
drwxrwxr-x 7 ziad ziad 4.0K Jun 11 01:31 arm-cortex_a8-linux-gnueabihf
drwxrwxr-x 2 ziad ziad 4.0K Jun 11 02:03 bin
-rw-rw-r-- 1 ziad ziad 2.0M Jun 11 02:03 build.log.bz2
drwxrwxr-x 2 ziad ziad 4.0K Jun 11 01:31 include
drwxrwxr-x 4 ziad ziad 4.0K Jun 11 01:31 lib
drwxrwxr-x 3 ziad ziad 4.0K Jun 11 01:31 libexec
drwxrwxr-x 5 ziad ziad 4.0K Jun 11 02:03 share
ziad@ziadpc:~/x-tools/arm-cortex_a8-linux-gnueabihf$ 
```
the `bin` directory is where you can find the cross-compiler and other tools, to use it in the terminal you should add it to the path variable.

```bash
ziad@ziadpc:~/x-tools/arm-cortex_a8-linux-gnueabihf/bin$ ls | grep gcc
lrwxrwxrwx 1 ziad ziad    33 Jun 11 01:31 arm-cortex_a8-linux-gnueabihf-cc -> arm-cortex_a8-linux-gnueabihf-gcc
-rwxr-xr-x 2 ziad ziad  1.8M Jun 11 02:03 arm-cortex_a8-linux-gnueabihf-gcc
-rwxr-xr-x 2 ziad ziad  1.8M Jun 11 02:03 arm-cortex_a8-linux-gnueabihf-gcc-13.2.0
-rwxr-xr-x 1 ziad ziad   35K Jun 11 02:03 arm-cortex_a8-linux-gnueabihf-gcc-ar
-rwxr-xr-x 1 ziad ziad   35K Jun 11 02:03 arm-cortex_a8-linux-gnueabihf-gcc-nm
-rwxr-xr-x 1 ziad ziad   35K Jun 11 02:03 arm-cortex_a8-linux-gnueabihf-gcc-ranlib
```

add it to the path variables by executing the following command:

```bash
PATH=~/x-tools/arm-cortex_a8-linux-gnueabihf/bin:$PATH
```

now test:
```bash
ziad@ziadpc:~/x-tools/arm-cortex_a8-linux-gnueabihf/bin$ arm-cortex_a8-linux-gnueabihf-gcc
arm-cortex_a8-linux-gnueabihf-gcc: fatal error: no input files
compilation terminated.
```
it should output something like this. In case of failure double-check the path of the output of crosstool-ng and check the existence of gcc in the directory as I did in the previous step.

**Test the compilation**:

we will use a simple program:
```c
//main.c
#include <stdio.h>
int main(){
    printf("Hello World! \n");
    return 0 ;
}
```

then compile it:

```bash
ziad@ziadpc:~/toolchain_playground$ arm-cortex_a8-linux-gnueabihf-gcc main.c -o helloworld.arm
=ziad@ziadpc:~/toolchain_playground$ ls
total 20K
drwxrwxr-x 19 ziad ziad 4.0K Jun 12 15:47 crosstool-ng
-rwxrwxr-x  1 ziad ziad  12K Jun 12 18:13 helloworld.arm
-rw-rw-r--  1 ziad ziad   74 Jun 12 18:10 main.c
```

execute it on an x86 machine
```
ziad@ziadpc:~/toolchain_playground$ ./helloworld.arm 
bash: ./helloworld.arm: cannot execute binary file: Exec format error
```
can't be executed as expected. to know more information about a file use the command `file`.
```bash
ziad@ziadpc:~/toolchain_playground$ file helloworld.arm 
helloworld.arm: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-armhf.so.3, for GNU/Linux 6.4.0, with debug_info, not stripped
```

### 4.2 Find out about the compiler
from the previous command we see that the compiler compiles the source code with some configurations, what are the configurations of the compiler, and how to set them for specific out, which will be introduced in this section.

**Finding Information about a compiler**:

in case you are working with a new compiler and you want to know about it. use the following command

```
arm-cortex_a8-linux-gnueabihf-gcc --version
```

```bash
ziad@ziadpc:~/toolchain_playground$ arm-cortex_a8-linux-gnueabihf-gcc --version
arm-cortex_a8-linux-gnueabihf-gcc (crosstool-NG 1.26.0) 13.2.0
Copyright (C) 2023 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
```

to find its configuration use `-v`:

```bash
ziad@ziadpc:~/toolchain_playground$ arm-cortex_a8-linux-gnueabihf-gcc -v
Using built-in specs.
COLLECT_GCC=arm-cortex_a8-linux-gnueabihf-gcc
COLLECT_LTO_WRAPPER=/home/ziad/x-tools/arm-cortex_a8-linux-gnueabihf/libexec/gcc/arm-cortex_a8-linux-gnueabihf/13.2.0/lto-wrapper
Target: arm-cortex_a8-linux-gnueabihf
Configured with: /home/ziad/toolchain_playground/crosstool-ng/.build/arm-cortex_a8-linux-gnueabihf/src/gcc/configure --build=x86_64-build_pc-linux-gnu --host=x86_64-build_pc-linux-gnu --target=arm-cortex_a8-linux-gnueabihf --prefix=/home/ziad/x-tools/arm-cortex_a8-linux-gnueabihf --exec_prefix=/home/ziad/x-tools/arm-cortex_a8-linux-gnueabihf 

--with-sysroot=/home/ziad/x-tools/arm-cortex_a8-linux-gnueabihf/arm-cortex_a8-linux-gnueabihf/sysroot --enable-languages=c,c++ --with-cpu=cortex-a8 --with-fpu=neon --with-float=hard 

--with-pkgversion='crosstool-NG 1.26.0' --enable-__cxa_atexit --disable-libmudflap --disable-libgomp --disable-libssp --disable-libquadmath --disable-libquadmath-support --disable-libsanitizer --disable-libmpx --with-gmp=/home/ziad/toolchain_playground/crosstool-ng/.build/arm-cortex_a8-linux-gnueabihf/buildtools --with-mpfr=/home/ziad/toolchain_playground/crosstool-ng/.build/arm-cortex_a8-linux-gnueabihf/buildtools --with-mpc=/home/ziad/toolchain_playground/crosstool-ng/.build/arm-cortex_a8-linux-gnueabihf/buildtools --with-isl=/home/ziad/toolchain_playground/crosstool-ng/.build/arm-cortex_a8-linux-gnueabihf/buildtools --enable-lto --enable-threads=posix --enable-target-optspace --enable-plugin --enable-gold --disable-nls --disable-multilib --with-local-prefix=/home/ziad/x-tools/arm-cortex_a8-linux-gnueabihf/arm-cortex_a8-linux-gnueabihf/sysroot --enable-long-long
Thread model: posix
Supported LTO compression algorithms: zlib zstd
gcc version 13.2.0 (crosstool-NG 1.26.0) 
```
Configurations to check:

* ---with-sysroot=/home/ziad/x-tools/arm-cortex_a8-linux-gnueabihf/arm-cortex_a8-linux-gnueabihf/sysroot  This is the default sysroot directory; see the following section for an explanation.

* --enable-languages=c,c++: Using this, we have both C and C++ languages enabled.
* --with-cpu=cortex-a8: The code is generated for an ARM Cortex A8 core.
* --with-float=hard: Generates opcodes for the floating-point unit and uses the VFP registers for parameters.
* --enable-threads=posix: This enables the POSIX threads.

these are default settings for a compiler, for overriding these configurations you can use the command line. for example for compiling to cortex-a5 instead of cortex-a8:

```bash
ziad@ziadpc:~/toolchain_playground$ arm-cortex_a8-linux-gnueabihf-gcc -mcpu=cortex-a5 main.c -o hello.arma5
```

### 4.3 The sysroot, library, and header files
from the outputs of the toolchain are libraries, binaries, headers, and some configuration files, where are these files stored? The answer is in the **sysroot** directory.

to see the location of **sysroot** directory use the following:
```bash
arm-cortex_a8-linux-gnueabihf-gcc -print-sysroot
```

```bash
ziad@ziadpc:~/toolchain_playground$ arm-cortex_a8-linux-gnueabihf-gcc -print-sysroot
/home/ziad/x-tools/arm-cortex_a8-linux-gnueabihf/arm-cortex_a8-linux-gnueabihf/sysroot
```

to change the directory of the sysroot you can use `-sysroot=` in the command line on executing `gcc`.


**Content of sysroot**:

```bash
ziad@ziadpc:~/toolchain_playground$ ls /home/ziad/x-tools/arm-cortex_a8-linux-gnueabihf/arm-cortex_a8-linux-gnueabihf/sysroot
total 20K
drwxrwxr-x 2 ziad ziad 4.0K Jun 11 01:03 etc
drwxrwxr-x 2 ziad ziad 4.0K Jun 11 01:31 lib
drwxrwxr-x 2 ziad ziad 4.0K Jun 11 01:03 sbin
drwxrwxr-x 8 ziad ziad 4.0K Jun 11 01:02 usr
drwxrwxr-x 3 ziad ziad 4.0K Jun 11 01:03 var
```

```bash
ziad@ziadpc:~/toolchain_playground$ ls /home/ziad/x-tools/arm-cortex_a8-linux-gnueabihf/arm-cortex_a8-linux-gnueabihf/sysroot/usr
total 24K
drwxrwxr-x  2 ziad ziad 4.0K Jun 11 01:36 bin
drwxrwxr-x 34 ziad ziad 4.0K Jun 11 01:48 include
drwxrwxr-x  7 ziad ziad 4.0K Jun 11 01:36 lib
drwxrwxr-x  3 ziad ziad 4.0K Jun 11 01:02 libexec
drwxrwxr-x  2 ziad ziad 4.0K Jun 11 01:03 sbin
drwxrwxr-x  7 ziad ziad 4.0K Jun 11 02:03 share
```

* lib:
    
 contains the shared objects (`.o`) for the C Library and the dynamic linker/loader, `ld-linux`

* sbin:

 provides the ldconfig utility that is used for optimizing the library loading path

* usr/bin: 

 contains the utilities that are compiled to the target (to run on the target)
 ```bash
    ziad@ziadpc:~/toolchain_playground$ file /home/ziad/x-tools/arm-cortex_a8-linux-gnueabihf/arm-cortex_a8-linux-gnueabihf/sysroot/usr/bin/clear
/home/ziad/x-tools/arm-cortex_a8-linux-gnueabihf/arm-cortex_a8-linux-gnueabihf/sysroot/usr/bin/clear: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-armhf.so.3, for GNU/Linux 6.4.0, stripped
 ```

* usr/include:
    
 contains the header files for all the libraries

* usr/lib:
    
 contains the static libraries and other installed libraries by the user

* usr/share:

 used for localization and internationalization

as shown some of these tools should be deployed into the target.

### 4.4 Other tools in the toolchain
you can find them in `~/x-tools/arm-cortex_a8-linux-gnueabihf/bin`

* `addr2line`: Converts program addresses into filenames and numbers by reading the debug symbol tables in an executable file. It is beneficial when decoding addresses printed out in a system crash report.
* `ar`: The archive utility creates static libraries.
* `as`: This is the GNU assembler.
* `c++filt`: This is used to demangle C++ and Java symbols.
* `cpp`: This is the C preprocessor and is used to expand #define, #include, and other similar directives. You seldom need to use this by itself.
* `elfedit`: This is used to update the ELF header of the ELF files.
* `g++`: This is the GNU C++ frontend, which assumes that source files contain C++ code.
* `gcc`: This is the GNU C frontend, which assumes that source files contain C code.
* `gcov`: This is a code coverage tool.
* `gdb`: This is the GNU debugger.
* `gprof`: This is a program profiling tool.
* `ld`: This is the GNU linker.
* `nm`: This lists symbols from object files.
* `objcopy`: This is used to copy and translate object files.
* `objdump`: This is used to display information from object files.
* `ranlib`: This creates or modifies an index in a static library, making the linking stage faster.
* `readelf`: This displays information about files in ELF object format.
* `size`: This lists section sizes and the total size.
* `strings`: This displays strings of printable characters in files.
* `strip`: This is used to strip an object file of debug symbol tables, thus making it smaller. Typically, you would strip all the executable code that is put onto the target.

```bash
ziad@ziadpc:~/toolchain_playground$ ls | grep helloworld.arm
total 32K
-rwxrwxr-x  1 ziad ziad  12K Jun 12 18:13 helloworld.arm
ziad@ziadpc:~/toolchain_playground$ file helloworld.arm #not stripped its size is 12K
helloworld.arm: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-armhf.so.3, for GNU/Linux 6.4.0, with debug_info, not stripped
ziad@ziadpc:~/toolchain_playground$ arm-cortex_a8-linux-gnueabihf-strip helloworld.arm 
ziad@ziadpc:~/toolchain_playground$ file helloworld.arm #stripped
helloworld.arm: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-armhf.so.3, for GNU/Linux 6.4.0, stripped
ziad@ziadpc:~/toolchain_playground$ ls | grep  helloworld.arm #5.5K 
total 28K
-rwxrwxr-x  1 ziad ziad 5.5K Jun 12 18:54 helloworld.arm
```

### 4.5 Components of the C library
C- library isn't a single library file, it consists of 4-parts implementing POSIX standards which are:

1. **libc**: the main C library that contains the well-known POSIX functions such as `printf`, `open`, `close`
2. **libm**: the math library that contains the math functions such as `cos`, `exp`, and `log`
3. **libpthread**: contains all the POSIX thread functions with their names beginning with `pthread_`
4. **librt**: the real-time library, has an extension to POSIX including shared memory and asynchronous I/O

## 5. Static and Shared Libraries and linking with them
programs are compiled and linked with the C Library, also programs are linked with other libraries. the linking is done via two approaches; static linking and dynamic/shared linking.
static linking means that the output program is packaged with the library in the same executable, while dynamic linking means that the output program depends on the library but is not compiled with it, it links to it in the runtime.

### 5.1 Static Libraries
The output program contains its code and adds to it the used code of the library. its libraries end with `.a`.

The statically linked program runs faster than dynamically linked programs since there is no overhead of loading the library, but its size will be larger than the dynamically linked program.

#### When to use the static library

1. when the linked library is small-sized, so no overhead of loading the library in the runtime
2. when you need to run the program before the filesystem that holds the library is loaded, or before the OS starts the runtime linker/loader
3. when you need to link a small part of the library to the program rather than linking the whole library

#### Compile against a static library
in the following example we will link a code with a static library.
to compile statically use the option `-static`
```c 
//main.c
#include <stdio.h>
int main(){
    printf("Hello World! \n");
    return 0 ;
}
````
```bash
ziad@ziadpc:~/toolchain_playground$ arm-cortex_a8-linux-gnueabihf-gcc  main.c -o notlinkingprogram
ziad@ziadpc:~/toolchain_playground$ ls
total 20K
drwxrwxr-x 19 ziad ziad 4.0K Jun 12 15:47 crosstool-ng
-rw-rw-r--  1 ziad ziad   74 Jun 12 18:10 main.c
-rwxrwxr-x  1 ziad ziad  12K Jun 13 03:09 notlinkingprogram
```
its size is **12K**

after statically linked 
```bash
ziad@ziadpc:~/toolchain_playground$ arm-cortex_a8-linux-gnueabihf-gcc  -static main.c -o statlinkingprogram
ziad@ziadpc:~/toolchain_playground$ ls
total 2.8M
drwxrwxr-x 19 ziad ziad 4.0K Jun 12 15:47 crosstool-ng
-rw-rw-r--  1 ziad ziad   74 Jun 12 18:10 main.c
-rwxrwxr-x  1 ziad ziad  12K Jun 13 03:09 notlinkingprogram
-rwxrwxr-x  1 ziad ziad 2.8M Jun 13 03:11 statlinkingprogram
```
see the difference between the statically linked program and the nonlinked program `2.8M` and `12K`. since we didn't provide for which library the program will linked against it will be linked against the C library by default.
#### Create a static library
creating a static library is the same as creating an archive of object files. The output of the library shouldn't be linked (i.e. the code should pass to the assembler and stop there in other words use `-c` option in `gcc`).

```c
//program1.c
#include "program1.h"
int sum (int a, int b){
    return a + b ;
}
```

```c
//program2.c
#include "program2.h"
int sub(int a, int b){
    return a -b ;
}
```

```c
//main.c
#include "program1.h"
#include "program2.h"
int main(){
    int a = sum(2,3);
    int b = sub(4,5);
}
```
1. **Compile and Assemble every source file of the library by using -c option**

```bash
ziad@ziadpc:~/Customize Linux Image/CH02 all about toolchains/Toolchain/code samples$ arm-cortex_a8-linux-gnueabihf-gcc program1.c -c
ziad@ziadpc:~/Customize Linux Image/CH02 all about toolchains/Toolchain/code samples$ arm-cortex_a8-linux-gnueabihf-gcc program1.c -c
```
2. **Archive the object files using ar tool with options r(replace) c (create) s(add symbol table) and make the output ends with .a**

```bash
ziad@ziadpc:~/Customize Linux Image/CH02 all about toolchains/Toolchain/code samples$ arm-cortex_a8-linux-gnueabihf-ar rcs libtest.a  *.o #every object file
```

```bash
ziad@ziadpc:~/Customize Linux Image/CH02 all about toolchains/Toolchain/code samples$ ls
total 32K
-rw-rw-r-- 1 ziad ziad 1.9K Jun 13 03:27 libtest.a
-rw-rw-r-- 1 ziad ziad  102 Jun 13 03:28 main.c
-rw-rw-r-- 1 ziad ziad   67 Jun 13 03:22 program1.c
-rw-rw-r-- 1 ziad ziad   74 Jun 13 03:19 program1.h
-rw-rw-r-- 1 ziad ziad  856 Jun 13 03:25 program1.o
-rw-rw-r-- 1 ziad ziad   64 Jun 13 03:22 program2.c
-rw-rw-r-- 1 ziad ziad   74 Jun 13 03:19 program2.h
-rw-rw-r-- 1 ziad ziad  856 Jun 13 03:26 program2.o
```

3. **Compile main.c with the static library**
```bash
ziad@ziadpc:~/Customize Linux Image/CH02 all about toolchains/Toolchain/code samples$ arm-cortex_a8-linux-gnueabihf-gcc main.c  -o main.o -static  
/home/ziad/x-tools/arm-cortex_a8-linux-gnueabihf/lib/gcc/arm-cortex_a8-linux-gnueabihf/13.2.0/../../../../arm-cortex_a8-linux-gnueabihf/bin/ld.bfd: /tmp/ccuBic5b.o: in function `main':
main.c:(.text+0x14): undefined reference to `sum'
/home/ziad/x-tools/arm-cortex_a8-linux-gnueabihf/lib/gcc/arm-cortex_a8-linux-gnueabihf/13.2.0/../../../../arm-cortex_a8-linux-gnueabihf/bin/ld.bfd: main.c:(.text+0x24): undefined reference to `sub'
collect2: error: ld returned 1 exit status
```
without specifying libtest.a library

```bash
ziad@ziadpc:~/Customize Linux Image/CH02 all about toolchains/Toolchain/code samples$ arm-cortex_a8-linux-gnueabihf-gcc main.c  -o main.o -static  libtest.a 
ziad@ziadpc:~/Customize Linux Image/CH02 all about toolchains/Toolchain/code samples$ ls
total 2.8M
-rw-rw-r-- 1 ziad ziad 1.9K Jun 13 03:27 libtest.a
-rw-rw-r-- 1 ziad ziad  102 Jun 13 03:28 main.c
-rwxrwxr-x 1 ziad ziad 2.8M Jun 13 03:46 main.o
-rw-rw-r-- 1 ziad ziad   67 Jun 13 03:22 program1.c
-rw-rw-r-- 1 ziad ziad   74 Jun 13 03:19 program1.h
-rw-rw-r-- 1 ziad ziad  856 Jun 13 03:25 program1.o
-rw-rw-r-- 1 ziad ziad   64 Jun 13 03:22 program2.c
-rw-rw-r-- 1 ziad ziad   74 Jun 13 03:19 program2.h
-rw-rw-r-- 1 ziad ziad  856 Jun 13 03:26 program2.o
```

check if it was statically linked by using the command `readelf -a` and grep for `Shared library`

```bash
ziad@ziadpc:~/Customize Linux Image/CH02 all about toolchains/Toolchain/code samples$ readelf -a main.o | grep "Shared lib"
 0x00000001 (NEEDED)                     Shared library: [libc.so.6]
```

only libc which is shared by default for every gcc compiled program (see the configuration section)

you can add the include directory of the library and organize it into the include directory out, and the source directory as uploaded in the repo.
```bash
arm-cortex_a8-linux-gnueabihf-gcc main.c   -I libtest/include libtest/output/libtest.a 
```

Note: we can use `-l<library name without lib and .a>` instead of supplying the full library name and provide the library directory as follows:
```bash
arm-cortex_a8-linux-gnueabihf-gcc main.c   -I libtest/include -ltest -L libtest/output/
```
```
libtest.a -> test
```
### 5.2 Shared/Dynamic Libraries
unlike static libraries, shared libraries are linked to the source code during runtime which allows:
* Better use of memory since it removes the duplication of the same library across different programs by providing one copy to link all programs with it
* easy to update libraries without recompiling the programs

#### Linking to shared library
as we did in the static compilation; the output of the library source code should be assembled without being linked, here in addition to being not linked, the object code should be **P**osition **I**ndependent, so it is free to the run time linker/loader to locate it to next free address. this is achieved by adding the option -fPIC (**P**osition **I**ndependent **C**ode)

the structure of the library directory is:
```
libtest/include:
-rw-rw-r-- 1 ziad ziad 74 Jun 13 03:19 program1.h
-rw-rw-r-- 1 ziad ziad 74 Jun 13 03:19 program2.h

libtest/output:
-rw-rw-r-- 1 ziad ziad 1.9K Jun 13 03:54 libtest.a
-rw-rw-r-- 1 ziad ziad  856 Jun 13 03:52 program1.o
-rw-rw-r-- 1 ziad ziad  856 Jun 13 03:53 program2.o

libtest/source:
-rw-rw-r-- 1 ziad ziad 78 Jun 13 03:51 program1.c
-rw-rw-r-- 1 ziad ziad 75 Jun 13 03:53 program2.c
```

1. **Compile and Assemble every source file of the library by using -c and -fPIC options**
```bash
ziad@ziadpc:~/Customize Linux Image/CH02 all about toolchains/Toolchain/code samples$ arm-cortex_a8-linux-gnueabihf-gcc libtest/source/pr
ogram1.c -fPIC -c -o libtest/output/program1.pio
ziad@ziadpc:~/Customize Linux Image/CH02 all about toolchains/Toolchain/code samples$ arm-cortex_a8-linux-gnueabihf-gcc libtest/source/program2.c -fPIC -c -o libtest/output/program2.pio
```

2. **Compile the object files to a single shared library with the option -shared and make the output end with .so**
```bash
ziad@ziadpc:~/Customize Linux Image/CH02 all about toolchains/Toolchain/code samples$ arm-cortex_a8-linux-gnueabihf-gcc -shared -o libtest/output/libtest.so libtest/output/*.pio
```

3. **Compile main.c against the dynamic library and compare the size of both files**

same as static linking
```bash
arm-cortex_a8-linux-gnueabihf-gcc main.c   -I libtest/include libtest/output/libtest.so -L libtest/output/ -o program.dynlnk
```
Note: here I didn't use the `-ltest` option because I have already libtest.a, so to avoid confusion I preferred to use the full name of the library.

4. **Check the Linked Library**
```bash
ziad@ziadpc:~/Customize Linux Image/CH02 all about toolchains/Toolchain/code samples$ readelf -a program.dynlnk | grep "Shared lib"
 0x00000001 (NEEDED)                     Shared library: [libtest/output/libtest.so]
 0x00000001 (NEEDED)                     Shared library: [libc.so.6]
```

#### Load a shared library
The OS starts a system loader/runtime linker, on executing `program. dynlnk` the loader will search for the required libraries in the  `/lib` and `/usr/lib` directories and will search in the paths in the `LD_LIBRARY_PATH` shell variable -if set-.
to add a directory path for a library to `LD_LIBRARY_PATH` use the following command
```bash
$ export LD_LIBRARY_PATH=/opt/lib:/opt/usr/lib:<yourpath\>
```

> Note: paths are colon-separated


![flowchart](https://i.ibb.co/hLQ3Ztm/flo-drawio-1.png)

#### Understanding shared library version numbers
since libraries may be updated, it may break its compatibility with existing applications, hence we need to have information about the compatibility of the library. This information is called the library **release version**.

Library updates have two types:   

* Updates to add new features or fix bugs, which maintains the backward compatibility
* Updates that break the backward compatibility

the term **backward compatibility** means that when an application is linked against a shared library version if the update of the library is backward compatible then the application can run against the updated library without any code modifications or potential errors. However, if the update isn't backwards compatible then the application may throw errors in runtime or on compilation (if the developer decides to rebuild it).

the release version is something like this `6.4` at the end of the library name such as `libncurses.so.6.4`.

in release version `6.4.0`:

* (6) **Major revision/Interface number**: this version does not support backward compatibility with older versions (e.g. 6.0 is not compatible with 5.0). this number is called 

* (4) **Minor revision**: maybe a feature added, collection of bug fixes, hence it supports backward compatibility with older Minor versions (e.g. 6.4 compatible 6.2 )

* (0) **Bug fix release**

So the most important number from them for a runtime linker is the **interface number**.

**How does the runtime linker handle different library versions and their dependencies?**

1. every library has an attribute called **SONAME**, which returns the release version with the interface number only.
```bash
ziad@ziadpc:~/x-tools/arm-cortex_a8-linux-gnueabihf/arm-cortex_a8-linux-gnueabihf/sysroot/usr/lib$ readelf -a libform.so | grep "SONAME"
 0x0000000e (SONAME)                     Library soname: [libform.so.6]
```
2. a linked program requests the interface number of its linked library only, since any minor revision or bug fixes will work with the program

3. a program requests `libform.6`, so the runtime linker will search in its known directories (e.g. `usr/bin`) and search for the `libform` file between symbolic link files


4. after successfully finding the `libform.6` symbolic link file, the linker will follow this link and load the actual file

```
libform.so.6 -> libform.so.6.4
```

Note: `libform.so.6` symlink is searched instead of `libform.so.6.4` actual file, because `libform.so.6.4` may be continuously updated, then its minor numbers will be changed. instead the `libform.so.6` will change in case of a major update.

that's why for a library we have at least four files for it in the usr/lib directory

```bash
ziad@ziadpc:~/x-tools/arm-cortex_a8-linux-gnueabihf/arm-cortex_a8-linux-gnueabihf/sysroot/usr/lib$ ls | grep libform
-rw-r--r-- 1 ziad ziad 115K Jun 11 01:36 libform.a
lrwxrwxrwx 1 ziad ziad   12 Jun 11 01:36 libform.so -> libform.so.6
lrwxrwxrwx 1 ziad ziad   14 Jun 11 01:36 libform.so.6 -> libform.so.6.4
-rwxrwxr-x 1 ziad ziad  92K Jun 11 01:36 libform.so.6.4
```

**What if a program requests an older version of the library**
1. the `usr/lib` directory may contain more than one version of a library
2. the runtime linker will search for the appropriate **SONAME** to link against
3. on finding the appropriate version the runtime linker will follow the symbolic link to load the file.

**General Searching Steps:**

![flowchart](https://i.ibb.co/W6V0WCs/fc-drawio.png)


## 6. The art of cross compiling
executing cross-compilation from the terminal can't scale beyond a toy program. to use cross-compilation effectively a build system should be used.

In this section, the following buildsystems are introduced:

* Makefiles
* GNU Autotools
* CMake

### 6.1 Makefiles

The Make utility is a software tool for managing and maintaining computer programs consisting of many component files. The make utility automatically determines which pieces of a **large program** need to be recompiled, and issues commands to recompile them. Makefile is a way of automating software building procedures and other complex tasks with dependencies.

Make reads its instruction from **Makefile** (called the descriptor file) by default.

Makefile sets a set of rules to determine which parts of a program need to be recompiled, and issues a command to recompile them.


some packages are simply cross-compiled by the `make` utility, these packages include:
* Linux kernel
* U-Boot bootloader
* BusyBox
For each of these, you only need to put the toolchain prefix in the make variable `CROSS_COMPILE` or, you can set it as a shell variable

**calling makefile with cross-compile**
```bash
make CROSS_COMPILE=arm-cortex_a8-linux-gnueabihf-
```
**Setting CROSS_COMPILE as a shell variable**
```bash
export CROSS_COMPILE=arm-cortex_a8-linux-gnueabihf-
make
```
**Note**: *don't set the CORSS_CONFIG variable to be persistent among all shell sessions because it may conflict with other commands.*

here is a [good resource](https://www3.nd.edu/~zxu2/acms60212-40212/Makefile.pdf) for make files

**Autotools** and **CMake** both generates makefile, except **CMake** supports other ways of building projects depending on which platform(s) is targeting (Linux in our case).

### 6.2 Autotools
The name Autotools refers to a group of tools that are used as the build system in many open-source projects. The components, together with the appropriate project pages, are as follows:

* [GNU Autoconf](https://www.gnu.org/software/autoconf/autoconf.html)
* [GNU Automake](https://www.gnu.orgsavannah-checkouts/gnu/automake/)
* [GNU Libtool](https://www.gnu.org/software/libtool/libtool.html)
* [Gnulib](https://www.gnu.org/software/gnulib/)

Packages that use Autotools come with a script named `configure` (such that in crosstool-ng) that checks dependencies and generates makefiles according to what it finds. The configure script may also allow you to enable or disable certain features. You can find the options on offer by running `./configure --help`.

To configure, build, and install a package for the native operating system, you would typically run the following three commands (as we did in crosstool-ng):
```bash
./configure
make
sudo make install
```
auto tools can be configured by setting these shell variables:
* `CC`: The C compiler command.
* `CFLAGS`: Additional C compiler flags.
* `CXX`: The C++ compiler command.
* `CXXFLAGS`: Additional C++ compiler flags.
* `LDFLAGS`: Additional linker flags; for example, if you have libraries in a non-standard directory <lib dir>, you would add it to the library search path
by adding -L<lib dir>.
* `LIBS`: Contains a list of additional libraries to pass to the linker; for instance, -lm for the math library.
* `CPPFLAGS`: Contains C/C++ preprocessor flags; for example, you would add -I<include dir> to search for headers in a non-standard directory <include dir>.
* `CPP`: The C preprocessor to use.

Sometimes you need to set the C-Compiler `CC` shell variable only as follows:
```bash
CC=arm-cortex_a8-linux-gnueabihf-gcc ./configure
```
you may encounter this error
```bash
[…]
checking for suffix of executables...
checking whether we are cross-compiling... configure: error: in
'/home/ziad/sqlite-autoconf-3330000':
configure: error: cannot run C compiled programs.
If you meant to cross compile, use '--host'.
See 'config.log' for more detail
```
The reason for the failure is that **configure often tries to discover the capabilities of the toolchain by compiling snippets of code and running them to see what happens**, which cannot work if the program has been cross-compiled.

**Autotools understands three different types of machines that may be involved when compiling a package**:
* Build: The computer that builds the package, which defaults to the current machine.
* Host: The computer the program will run on. For a native compile, this is left blank and it defaults to be the same computer as Build. When you are cross-compiling, set it to be the name of your toolchain.
* Target: The computer the program will generate code for. You would set this when building a cross-compiler.

So to solve the previous issue do the following:
>Pass --host=\<host> to configure when you are cross-compiling so that configure searches your system for the cross-compiling toolchain targeting the specified \<host> platform. That way, configure does not try to run snippets of non-native code as part of the configuration step.
```bash
CC=arm-cortex_a8-linux-gnueabihf-gcc ./configure --host=arm-cortex_a8-linux-gnueabihf
```
Note: the default installation directory is <sysroot>/usr/local/\*. not in the default directory of the OS, so you should install it in <sysroot>/usr/\* so that the header files and libraries would be picked up from their default locations.

The complete command to configure a typical Autotools package is as follows:

```bash
CC=arm-cortex_a8-linux-gnueabihf-gcc ./configure --host=arm-cortex_a8-linux-gnueabihf --prefix=/usr
```

#### An example: SQLite
in this section, we will build The SQLite library for beaglebone. SQLite implements a simple relational database and is quite popular on embedded devices and mobile phones. 

1. **clone SQLite source code**

```bash
wget http://www.sqlite.org/2020/sqlite-autoconf-3330000.tar.gz
tar xf sqlite-autoconf-3330000.tar.gz
cd sqlite-autoconf-3330000
```

```bash
ziad@ziadpc:~/toolchain_playground/sqlite$ wget http://www.sqlite.org/2020/sqlite-autoconf-3330000.tar.gz
tar xf sqlite-autoconf-3330000.tar.gz
cd sqlite-autoconf-3330000
--2024-06-14 03:19:32--  http://www.sqlite.org/2020/sqlite-autoconf-3330000.tar.gz
Resolving www.sqlite.org (www.sqlite.org)... 2600:3c00::f03c:91ff:fe96:b959, 45.33.6.223
Connecting to www.sqlite.org (www.sqlite.org)|2600:3c00::f03c:91ff:fe96:b959|:80... failed: Connection timed out.
Connecting to www.sqlite.org (www.sqlite.org)|45.33.6.223|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 2913759 (2.8M) [application/x-gzip]
Saving to: ‘sqlite-autoconf-3330000.tar.gz’

sqlite-autoconf-3330000.tar.gz      100%[=================================================================>]   2.78M   807KB/s    in 4.2s    

2024-06-14 03:21:53 (684 KB/s) - ‘sqlite-autoconf-3330000.tar.gz’ saved [2913759/2913759]
```
2. **Run the configuration script**

set the options with our desired configurations.
```bash
CC=arm-cortex_a8-linux-gnueabihf-gcc ./configure --host=arm-cortex_a8-linux-gnueabihf --prefix=/usr
```

```bash
ziad@ziadpc:~/toolchain_playground/sqlite/sqlite-autoconf-3330000$ CC=~/x-tools/arm-cortex_a8-linux-gnueabihf/bin/arm-cortex_a8-linux-gnueabihf-gcc ./configure --host=arm-cortex_a8-linux-gnueabihf --prefix=/usr
checking for a BSD-compatible install... /usr/bin/install -c
checking whether build environment is sane... yes
checking for arm-cortex_a8-linux-gnueabihf-strip... no
checking for strip... strip
checking for a thread-safe mkdir -p... /usr/bin/mkdir -p
checking for gawk... gawk
checking whether make sets $(MAKE)... yes
checking whether make supports nested variables... yes
....
```

Make sure you are specifying the correct path of the C Compiler.

3. **Run the make utility**

since autotools don't generate executables but they generate makefiles then we will execute the make utility.

```bash
make
```

```bash
ziad@ziadpc:~/toolchain_playground/sqlite/sqlite-autoconf-3330000$ make
/bin/bash ./libtool  --tag=CC   --mode=compile /home/ziad/x-tools/arm-cortex_a8-linux-gnueabihf/bin/arm-cortex_a8-linux-gnueabihf-gcc -DPACKAGE_NAME=\"sqlite\" -DPACKAGE_TARNAME=\"sqlite\" -DPACKAGE_VERSION=\"3.33.0\"
```

4. **Install the library to the toolchain directory**

by default, it will install into /usr/lib of the host machine not in the \<sysroot>/usr/lib directory which will be deployed into the target.

```bash
make DESTDIR=$(arm-cortex_a8-linux-gnueabihf-gcc -print-sysroot) install
```

```bash
ziad@ziadpc:~/toolchain_playground/sqlite/sqlite-autoconf-3330000$ sudo make DESTDIR=$(arm-cortex_a8-linux-gnueabihf-gcc -print-sysroot) install
make[1]: Entering directory '/home/ziad/toolchain_playground/sqlite/sqlite-autoconf-3330000'
 /usr/bin/mkdir -p '/home/ziad/x-tools/arm-cortex_a8-linux-gnueabihf/arm-cortex_a8-linux-gnueabihf/sysroot/usr/lib'
 /bin/bash ./libtool   --mode=install /usr/bin/install -c   libsqlite3.la '/home/ziad/x-tools/arm-cortex_a8-linux-gnueabihf/arm-cortex_a8-linux-gnueabihf/sysroot/usr/lib'
libtool: install: /usr/bin/install -c .libs/libsqlite3.so.0.8.6 /home/ziad/x-tools/arm-cortex_a8-linux-gnueabihf/arm-cortex_a8-linux-gnueabihf/sysroot/usr/lib/libsqlite3.so.0.8.6
....
```

If the command didn't succeed here are some reasons:
1. check that cross-compile is added to the path
 ```bash
    PATH=~/x-tools/arm-cortex_a8-linux-gnueabihf/bin:$PATH
 ```
2. rerun with `sudo` command
3. you didn't deselect the option of `render toolchain as read-only` while configuring the toolchain from the `crosstool-ng`

to check if SQLite was successfully installed or not, you should find that various files have been added to your toolchain:
* **\<sysroot>/usr/bin**: sqlite3: This is a command-line interface for SQLite that you can install and run on the target.
* **\<sysroot>/usr/lib**: libsqlite3.so.0.8.6, libsqlite3.so.0, libsqlite3.so, libsqlite3.la, libsqlite3.a: These are the shared and static libraries.
* **\<sysroot>/usr/lib/pkgconfig**: sqlite3.pc: This is the package configuration file, as described in the following section
* **\<sysroot>/usr/lib/include**: sqlite3.h, sqlite3ext.h: These are the header files.
* **\<sysroot>/usr/share/man/man1**: sqlite3.1: This is the manual page.


### 6.3 Autotools; Package configuration
the previous section was to build a package, but what if the package depends on another package, they should be cross-compiled also. Autotools relies on a utility called pkg-config to gather vital information about packages cross-compiled by Autotools.

Tracking package dependencies is quite complex as shown in [Linux System admin repo](https://github.com/ziadasem/Linux-System-Admin/tree/main/2-%20Applications%20and%20package%20managment). The package configuration utility [pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config/) helps in the following:
* tracking which packages are installed 
* which compile flags each package needs 

by keeping a database of Autotools packages in [sysroot]/usr/lib/pkgconfig. For instance, the one for SQLite3 is named sqlite3.pc and contains essential information needed by other packages that need to make use of it:

```bash
cat $(arm-cortex_a8-linux-gnueabihf-gcc -print-sysroot)/usr/
lib/pkgconfig/sqlite3.pc
#Package Information for pkg-config
prefix=/usr
exec_prefix=${prefix}
libdir=${exec_prefix}/lib
includedir=${prefix}/include
Name: SQLite
Description: SQL database engine
Version: 3.33.0
Libs: -L${libdir} -lsqlite3
Libs.private: -lm -ldl -lpthread
Cflags: -I${includedir}
```
You can use pkg-config to extract information in a form that you can feed straight to gcc. In the case of a library like libsqlite3, you want to know the library name (--libs) and any special C flags (--cflags):

```bash
pkg-config sqlite3 --libs --cflags
Package sqlite3 was not found in the pkg-config search path.
Perhaps you should add the directory containing 'sqlite3.pc'
to the PKG_CONFIG_PATH environment variable
No package 'sqlite3' found
```

That failed because it was looking in the host's sysroot and the development package for libsqlite3 has not been installed on the host. You need to point it at the sysroot of the target toolchain by setting the PKG_CONFIG_LIBDIR shell variable:
```bash
export PKG_CONFIG_LIBDIR=$(arm-cortex_a8-linux-gnueabihf-gcc -print-sysroot)/usr/lib/pkgconfig
```
```bash
ziad@ziadpc:~/toolchain_playground/sqlite$ pkg-config sqlite3 --libs --cflags
-lsqlite3
```
Now the output is -lsqlite3. In this case, you knew that already, but generally you wouldn't, so this is a valuable technique. The final commands to compile would be the following:
```bash
$ export PKG_CONFIG_LIBDIR=$(arm-cortex_a8-linux-gnueabihf-gcc \
-print-sysroot)/usr/lib/pkgconfig
$ arm-cortex_a8-linux-gnueabihf-gcc $(pkg-config sqlite3
--cflags --libs) \
sqlite-test.c -o sqlite-test
```
### 6.4 Problems with cross compiling

sqlite3 is a well-behaved package and cross-compiles nicely, but not all packages are the same. Typical pain points include the following:
* Some libraries have their own configuration script that does not behave like the Autotools such as `zlib` 
* Configure scripts that read pkg-config information, headers, and other files from the host, disregarding the --host override
* Scripts that insist on trying to run cross-compiled code

Each case requires careful analysis of the error and additional parameters to the configure script to provide the correct information, or patches to the code to avoid the problem altogether. also keep in mind that one package may have many dependencies, especially with programs that have a graphical interface using `GTK` or `Qt`, or that handle multimedia content. As an example, `mplayer`, which is a popular tool for playing multimedia content, **has dependencies on over 100 libraries. It would take weeks of effort to build them all.**

Therefore, It is not recommended to manually cross-compiling components for the target in this way, except when there is no alternative or the number of packages to build is small. A much better approach is to use a build tool such as Buildroot or the Yocto Project or avoid the problem altogether by setting up a native build environment for your target architecture.
Now you can see why distributions such as Debian are always compiled natively.

### 6.5 CMake
CMake is an extensible, open-source system that manages the build process in an operating system- and compiler-independent manner.


Unlike many cross-platform systems such as autotools, CMake is designed to be used in conjunction with the native build environment. Simple configuration files placed in each source directory (called `CMakeLists.txt` files) are used to generate standard build files (e.g., Makefiles on Unix and projects/workspaces in Windows MSVC), which are used in the usual way. This differs from autotools, which generate `make` files only.

CMake can generate a native build environment that will compile source code, create libraries, generate wrappers, and build executable binaries in arbitrary combinations. CMake supports in-place and out-of-place builds and can therefore support multiple builds from a single source tree.


This section isn't a full explanation of `CMake`; it introduces cross-compilation using `CMake`. You can find a full tutorial in the [CMake Tutorial](https://medium.com/@onur.dundar1/cmake-tutorial-585dd180109b) or in the [CMake manual](https://cmake.org/cmake/help/latest/index.html).

To configure, build, and install a package for a native Linux operating system, run the following commands (make sure that the package directory has a `CMakeLists.txt` file):

```bash
ziad@ziadpc:~/cmake_playground$ ls
total 12K
-rw-rw-r-- 1 ziad ziad  856 Jun 13 23:30 CMakeLists.txt
drwxrwxr-x 3 ziad ziad 4.0K Jun 13 22:45 lib
-rw-rw-r-- 1 ziad ziad  169 Jun 13 23:00 main.cpp
```
```bash
cmake . #Generates a make file (Linux)
make    #run the make utility directed by Makefile
sudo make install #install to /usr/bin
```

```bash
ziad@ziadpc:~/cmake_playground$ cmake .
-- The C compiler identification is GNU 11.4.0
-- The CXX compiler identification is GNU 11.4.0
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Check for working C compiler: /usr/bin/cc - skipped
-- Detecting C compile features
-- Detecting C compile features - done
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Check for working CXX compiler: /usr/bin/c++ - skipped
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Configuring done
-- Generating done
-- Build files have been written to: /home/ziad/cmake_playground
ziad@ziadpc:~/cmake_playground$ make
[ 25%] Building CXX object CMakeFiles/math.dir/lib/math/math.cpp.o
[ 50%] Linking CXX shared library lib/libmath.so
[ 50%] Built target math
[ 75%] Building CXX object CMakeFiles/cmake_hello.dir/main.cpp.o
[100%] Linking CXX executable bin/cmake_hello
[100%] Built target cmake_hello
ziad@ziadpc:~/cmake_playground$ sudo make install
[sudo] password for ziad: 
Consolidate compiler generated dependencies of target math
[ 50%] Built target math
Consolidate compiler generated dependencies of target cmake_hello
[100%] Built target cmake_hello
```
On Linux, the native build tool is GNU make, so CMake generates makefiles by default for us to build with. Oftentimes, to maintain an organized directory hierarchy, we want to perform out-of-source builds (build objects to other directories) so that object files and other build artifacts remain separate from source files.

To configure an out-of-source build in a subdirectory named `build`, run the following commands:

```bash
mkdir build
cd build
cmake ..
```
Or use the following in case you don't want to create a directory:

```bash
cmake -H. -Bbuild
#H indicates source directory
#B indicates the build directory
#run it from the source directory. This will create a directory named build
```
This will generate the makefiles inside a `build` subdirectory within the project directory where the `CMakeLists.txt` file is located. The `CMakeLists.txt` file is the CMake equivalent of the configure script for Autotools-based projects.

```bash
ziad@ziadpc:~/cmake_playground$ cmake -H. -Bbuild
-- The C compiler identification is GNU 11.4.0
-- The CXX compiler identification is GNU 11.4.0
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Check for working C compiler: /usr/bin/cc - skipped
-- Detecting C compile features
-- Detecting C compile features - done
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Check for working CXX compiler: /usr/bin/c++ - skipped
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Configuring done
-- Generating done
-- Build files have been written to: /home/ziad/cmake_playground/build
ziad@ziadpc:~/cmake_playground$ ls
total 16K
drwxrwxr-x 5 ziad ziad 4.0K Jun 14 18:53 build
-rw-rw-r-- 1 ziad ziad  856 Jun 13 23:30 CMakeLists.txt
drwxrwxr-x 3 ziad ziad 4.0K Jun 14 18:47 lib
-rw-rw-r-- 1 ziad ziad  169 Jun 13 23:00 main.cpp
```
We can then build the project out-of-source from inside the build directory and install the package just as before:

```bash
make
sudo make install
```

CMake uses absolute paths, so the build subdirectory cannot be copied or moved once the `makefiles` have been generated, or any subsequent make step will likely fail. Note that CMake defaults to installing packages into system directories such as `/usr/bin`, even for out-of-source builds.

Here, you should use CMake variables and set them in the `CMakeLists.txt` or by executing `cmake` in the terminal.

```bash
cmake .. -D CMAKE_INSTALL_PREFIX=../_build
#or
cmake -H. -Bbuild -D CMAKE_INSTALL_PREFIX=../_build
``` 
No need to use the `sudo` command since the installation directory will not be the root.

Similarly, we can use another CMake command-line option to generate makefiles for cross-compilation:

```bash
cmake .. -D CMAKE_C_COMPILER="/usr/local/share/x-tools/
arm-cortex_a8-linux-gnueabihf-gcc"
```
But the best practice for cross-compiling with CMake is to create a toolchain file that sets `CMAKE_C_COMPILER` and `CMAKE_CXX_COMPILER` in addition to other relevant variables for targeting embedded Linux.

#### CMake with libraries
CMake works best when we design our software in a modular way by enforcing well-defined API boundaries between libraries and components.

Here are some key terms that come up time and again in CMake:
- Target: A software component such as a library or executable.
- Properties: Include the source files, compiler options, and linked libraries needed to build a target.
- Package: A CMake file that configures an external target for building, as if it were defined within your `CMakeLists.txt` itself.

For example, if we had a CMake-based executable named `dummy` that needed to take a dependency on SQLite, we could define the following `CMakeLists.txt`:


```cmake
cmake_minimum_required (VERSION 3.0)
project (Dummy)
add_executable(dummy dummy.c)
find_package (SQLite3)
target_include_directories(dummy PRIVATE ${SQLITE3_INCLUDE_
DIRS})
target_link_libraries (dummy PRIVATE ${SQLITE3_LIBRARIES})
```
The `find_package` command searches for a package (SQLite3 in this case) and imports it. Then, the external target can be added as a dependency (linked) to the `dummy` executable with the `target_link_libraries` command.

CMake comes with numerous finders for popular C and C++ packages including OpenSSL, Boost, and protobuf, making native development much more productive than using pure makefiles alone.

The `PRIVATE` qualifier prevents details such as headers and flags from leaking outside of the `dummy` target. Using `PRIVATE` makes more sense when the target being built is a library instead of an executable. Think of targets as modules and attempt to minimize their exposed surface areas when using CMake to define your targets. Only employ the `PUBLIC` qualifier when necessary and utilize the `INTERFACE` qualifier for header-only libraries.

It is recommended to deal with many dependencies by modeling your application as a dependency graph with edges between targets. This graph should include not only the libraries that your application links to directly but also any transitive dependencies. **For best results, remove any cycles or other unnecessary dependencies seen in the graph**. It is often best to perform this exercise before you start coding. A little planning can make the difference between a clean, easily maintainable `CMakeLists.txt` and an inscrutable mess that nobody wants to touch.

## 7. Additional Information
### 7.1 POSIX
POSIX is a family of standards specified by the IEEE for maintaining compatibility between operating systems.POSIX defines both the system and user-level **application programming interfaces** (APIs), along with command line shells and utility interfaces.

**What does Standardization of POSIX provide?** 

when compiling a program that follows the standards of POSIX, it became compatible with every OS that implements the POSIX, since these OSes follow the same standard. Here are some features of using Standardization (especially POSIX): 
1. **Standardization between different UNIX-based** systems, as programs compiled for one of the UNIX-based systems can run on one another without modification

2. **The standardization between command line** utilities, as commands like `ls`,`cp`, and `grep` make them compatible with any Unix-based system 
3. **The standardization of a** command language for writing shell scripts, make scripts can be run on any POSIX-compliant system without modification.

**OSes that implement POSIX**
Many operating systems aim to be POSIX-compliant, including most UNIX variants (like BSD, AIX, HP-UX) and UNIX-like systems (like Linux and macOS). While Windows is not POSIX-compliant by default, there are subsystems and compatibility layers, like Windows Subsystem for Linux (WSL), that provide POSIX-like environments.

**Example of using POSIX**
consider a C-program that reads and writes from/to a file in Linux

```c
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>

#define FILENAME "helloworld.txt"

int main() {
    int fd;
    char buffer[256];
    const char *message = "Hello, World!\n";

    // Open the file for writing (create if it doesn't exist, truncate if it does)
    //O_WRONLY | O_CREAT | O_TRUNC -> File operations
 fd = open(FILENAME, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd == -1) {
        perror("Failed to open file");
        return 1;
 }

    // Write the message to the file
    if (write(fd, message, strlen(message)) == -1) {
        perror("Failed to write to file");
        close(fd);
        return 1;
 }
   

    // Read the content from the file
    ssize_t bytesRead = read(fd, buffer, sizeof(buffer) - 1);
    if (bytesRead == -1) {
        perror("Failed to read from file");
        close(fd);
        return 1;
 }

    // Null-terminate the buffer and print it
    buffer[bytesRead] = '\0';
    printf("Read from file: %s", buffer);

    // Close the file
    if (close(fd) == -1) {
        perror("Failed to close file");
        return 1;
 }

    return 0;
}

```

The functions of `open`, `write`, `read`, and `close` communicates with the OS via **system call** (will be discussed in another chapter), but it can be considered as the interface between the applications and the OS, this system call implements the POSIX standard, hence the application can communicate with OS(Linux).

The steps of opening a file that is abstracted by the `open` function are:

1. the **program** calls `fopen()` from **C Library** and prepares the file (specifying the file name and file operation)
2. the **C Library** makes a system call to the OS
3. the **OS** opens the file and returns a file descriptor to the **C Library**. This file descriptor is an integer representing the opened file
4. the **C Library** represents the returned file descriptor with the defined `FILE` structure
5. the **C Library** creates a pointer to this structure and returns it to the calling **program**, in case of failure to open a file, the C library handles this issue by returning a NULL pointer



### 7.2 API and interfaces
a good brief explanation of Interfaces and API on [Stack overflow](https://stackoverflow.com/questions/2171177/what-is-an-application-binary-interface-abi) states the following:

**Interface**: <br>It is an "existing entity" layer between the functionality and consumer of that functionality. An interface by itself doesn't do anything. It just invokes the functionality lying behind.

for example:

>A TV remote is an interface between the user and the TV. It is an existing entity, but useless (doesn't provide any functionality) by itself. All the functionality for each of those buttons on the remote is implemented in the television set.

another example that defines the user and the interface type.

* Command Line Interface (CLI):

 commands are the existing entities, the consumer is the user and functionality lies behind them.

 functionality: my software functionality which solves some purpose to which we are describing this interface.

 existing entities: commands

 consumer: user

* Graphical User Interface(GUI):
 
 window, buttons, etc. are the existing entities, and again the consumer is the user and functionality lies behind.

 functionality: my software functionality which solves some problems to which we are describing this interface.

 existing entities: windows, buttons, etc.

 consumer: user

* Application Programming Interface(API) 

 functions are the existing entities (and interfaces in languages that support OOP classes, objects, interfaces, ...etc), the consumer here is another program, not a user, and again functionality lies behind this layer.

 functionality: my software functionality which solves some problems to which we are describing this interface.

 existing entities: functions, Interfaces (array of functions).

 consumer: another program/application.

### 7.3 Application binary interface
 The ABI defines the structures and methods that your compiled application will use to access the external library, hence we can say that:
 for ABI:
  
 functionality: the software functionality in libraries or operating systems at the binary level.

 existing entities: functions, Interfaces (array of functions), and some standards for accessing data at the binary level.

 consumer: another program/application at the binary level.

hence it can be said that the ABI is the compiled version of API, also ABI is responsible for defining the following:

* Processor instruction set, with details like register file structure, stack organization, memory access types, etc
* Sizes, layouts, and alignments of basic data types that the processor can directly access
* Calling (e.g. of function) convention, which controls how the arguments of functions are passed, and return values retrieved; for example, it controls the following:
    * Whether all parameters are passed on the stack, or some are passed in registers
    * Which registers are used for which function parameters
    * Whether the first function parameter passed on the stack is pushed first or last
    * Whether the caller or callee is responsible for cleaning up the stack after the function call
* How an application should make system calls to the operating system
* In the case of a complete operating system ABI, the binary format of object files, program libraries, etc.

ABIs are important when it comes to applications that use external libraries. Libraries are full of code and other resources, but your program has to know how to locate what it needs inside the library file. Your ABI defines how the contents of a library are stored inside the file, and your program uses the ABI to search through the file and find what it needs. If everything in your system conforms to the same ABI, then any program can work with any library file, no matter who created it. Linux and Windows use different ABIs, so a Windows program won't know how to access a library compiled for Linux, for example, the extension of Linux shared libraries is `.so` while for Windows is `.dll`