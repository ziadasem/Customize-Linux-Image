# Toolchains
in this chapter, an explanation of tool chains, will be introduced in addition to working examples to generate a toolchain for `Qemu` and `BeagleBone Black`.

**why does toolchain important for an Embedded Linux project**

For an Embedded Linux project, The toolchain is the first element of embedded Linux and the starting point of the project. it will use be to compile all the other elements of embedded linux system on the target device which are:
* Bootloader
* Kernel
* RFS

The choices of toolchain at this early will have a profound impact on the final outcome. Since a toolchain should be:
* capable of making effective use of the target hardware by using the **optimum instruction set** for the target processor
* It should support the languages that the target requires
* have a solid implementation of the Portable Operating System Interface (POSIX) and other system interfaces, hint you can read more about POSIX in the [Additional Information](#10--additional-information) section

to get a toolchain, there are different methods some of them are:
* get a prebuilt toolchain, either by download and install it, or probably inside the Board Support Package shipped with the target hardware platform by the vendor
The drawback is that you don't have flexibility on your toolchain features (which C library? hard-float or soft-float? which ABI?)
* building from the source (e.g. use `Cross-Tool NG` tool)
* use a toolchain generated by a buildsystem which will be disscussed later (e.g. use `yocto` to generate a toolchain)

although in this chapter, the second method of generating a toolchain is used, a section about different getting prebuilt toolchains is introduced.

**Before Getting Start**
it is required to use A Linux-based host system (e.g. Ubuntu) with *autoconf, automake, bison, bzip2, cmake,flex, g++, gawk, gcc, gettext, git, gperf, help2man, libncurses5-dev, libstdc++6, libtool, libtool-bin, make, patch, python3-dev,rsync, texinfo, unzip, wget, and xz-utils* or their equivalents installed.

if you have ubuntu (or any other distribution uses apt package manager) execute the following command:
```bash
sudo apt-get install autoconf automake bison bzip2 cmake  flex g++ gawk gcc gettext git gperf help2man libncurses5-dev libstdc++6 libtool libtool-bin make patch python3-dev rsync texinfo unzip wget xz-utils
```

## 1- Introduction
 toolchain is a set of distinct software development tools that are linked (or chained) together by specific stages such as GCC, binutils and glibc. Optionally, a toolchain may contain other tools such as a debugger or a compiler for a specific programming language, such as C++. Quite often, 
 
**Versions of Toolchains**

* GNU toolchain

    The most used toolchain for Linux, and has the advantage of compatibility with the existing code base and support for a wide range of architectures and operating systems

* Clang compiler and the associated Low Level Virtual Machine (LLVM) project
    over the past few years,it have progressed to the point that it is now a viable alternative to a GNU toolchain One major distinction between LLVM and GNU-based toolchains is the licensing; LLVM has a BSD license while GNU has the GPL. it also faster than GNU in compilation and better diagnostics

### 1.1 Toolchain components
![toolchainblock diagram](https://i.ibb.co/HgW2hjK/toolchain.png)

![extended toolchainblock diagram](https://i.ibb.co/W3L8vRz/Untitled.png)

a standard toolchain consists from the following:

1- **Binutils**

he GNU Binutils is the first component of a toolchain. The GNU Binutils contains two very important tools:


* `as`, the assembler, that turns assembly code (generated by GCC) to binary
* `ld`, the linker, that links several object code into a library, or an executable (disscussed in the prerequisites)

Binutils also contains a couple of other binary file manipulation or analysis tools, such as `objcopy`, `objdump`, `nm`, `readelf`, `strip`, and so on. The Binutils [website](https://sourceware.org/binutils/docs-2.19/) has some documentation on all these tools. 

2- **Compilers**
in GNU toolchains we have GNU Compiler Collection (GCC), which are the compilers for C and other languages, which, depending on the version of GCC, include 
* C++
* Objective-C,
* Objective-C++
* Java
* Fortran
* Ada
* Go
They all use a common backend (the phases of compiler that generate the target-dependent code) that produces assembler code, which is fed to the GNU assembler.

3- **C library**
The C library implements the traditional POSIX API that can be used to develop userspace applications. It interfaces with the kernel through system calls and provides higher-level services.

Realistically, there are nowadays two options for the C Library:

    glibc is the C library from the GNU project. It's the C library used by virtually all desktop and server GNU/Linux systems. It's feature-full, portable, complies to standards, but a bit bloated.
    Embedded GLIBC (EGLIBC) is a variant of the GNU C Library (GLIBC) optimized for embedded systems. Its goals include reduced footprint, support for cross-compiling and cross-testing, while maintaining source and binary compatibility with GLIBC. The project is discontinued.
    uClibc is an alternate C library, which features a much smaller footprint. This library can be an interesting alternative if flash space and/or memory footprint is an issue. However, the space advantages gained using uClibc are becoming less important as the price of memory and flash continues to drop. It is still useful C library for embedded systems without an MMU.
    uClibc-ng is a spin-off of uClibc C library. The main goal of the spin-off is to do regular releases and do a lot of automatic runtime testing.
    musl New standard C library. musl is lightweight, fast, simple, free, and strives to be correct in the sense of standards-conformance and safety.

The C library has a special relation with the C compiler, so the choice of the C library must be done when the toolchain is generated. Once the toolchain has been built, it is no longer possible to switch to another library. 

## 10- Additional Information
### 10.1- POSIX
POSIX is a family of standards specified by the IEEE for maintaining compatibility between operating systems.POSIX defines both the system and user-level **application programming interfaces** (APIs), along with command line shells and utility interfaces.

**What does Standardization of POSIX provide?** 

when compiling a program that follows the standardes of POSIX, it became compatible for every os implements the POSIX, since these OSes follows the same standard. Here are some features of using Standardization (especially POSIX): 
1. **Standardization between different UNIX-based** system, as program compiled for one of UNIX-based system can run on one another without modification

2. **the standardization between command line** utilities, as commands like `ls`,`cp`, and `grep` make them compatible with any unix-based system 
3. **the standardization of a** command language for writing shell scripts, make scripts can be run on any POSIX-compliant system without modification.

**OSes that implement POSIX**
Many operating systems aim to be POSIX-compliant, including most UNIX variants (like BSD, AIX, HP-UX) and UNIX-like systems (like Linux and macOS). While Windows is not POSIX-compliant by default, there are subsystems and compatibility layers, like Windows Subsystem for Linux (WSL), that provide POSIX-like environments.

**Example of using POSIX**
consider a C-program that reads and writes from/to a file in Linux

```c
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>

#define FILENAME "helloworld.txt"

int main() {
    int fd;
    char buffer[256];
    const char *message = "Hello, World!\n";

    // Open the file for writing (create if it doesn't exist, truncate if it does)
    //O_WRONLY | O_CREAT | O_TRUNC -> File operations
    fd = open(FILENAME, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd == -1) {
        perror("Failed to open file");
        return 1;
    }

    // Write the message to the file
    if (write(fd, message, strlen(message)) == -1) {
        perror("Failed to write to file");
        close(fd);
        return 1;
    }
   

    // Read the content from the file
    ssize_t bytesRead = read(fd, buffer, sizeof(buffer) - 1);
    if (bytesRead == -1) {
        perror("Failed to read from file");
        close(fd);
        return 1;
    }

    // Null-terminate the buffer and print it
    buffer[bytesRead] = '\0';
    printf("Read from file: %s", buffer);

    // Close the file
    if (close(fd) == -1) {
        perror("Failed to close file");
        return 1;
    }

    return 0;
}

```

The functions of `open`, `write`, `read`, and `close` communicates with the OS via **system call** (will be disscussed later), but it can be considered as the interface between the applications and the OS, this system call implments the POSIX standard, hence the application can communicate with OS(Linux).