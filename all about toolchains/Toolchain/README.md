# Toolchains
in this chapter, an explanation of toolchains will be introduced in addition to working examples to generate a toolchain for `Qemu` (an emulator) and `BeagleBone Black`.

**Why is toolchain important for an Embedded Linux project**

For an Embedded Linux project, The toolchain is the first element of embedded Linux and the starting point of the project. it will use be to compile all the other elements of the embedded Linux system on the target device which are:
* Bootloader
* Kernel
* RFS

The choices of toolchains at this early will have a profound impact on the final outcome. Since a toolchain should be:
* capable of making effective use of the target hardware by using the **optimum instruction set** for the target processor
* It should support the languages that the target requires
* have a solid implementation of the Portable Operating System Interface (POSIX) and other system interfaces, hint you can read more about POSIX in the [Additional Information](#10--additional-information) section

to get a toolchain, there are different methods some of them are:
* get a prebuilt toolchain, either by downloading and installing it, or probably inside the Board Support Package shipped with the target hardware platform by the vendor
The drawback is that you don't have flexibility on your toolchain features (which C library? hard-float or soft-float? Which ABI?)
* building from the source (e.g. use the `Cross-Tool NG` tool)
* use a toolchain generated by a buildsystem which will be discussed later (e.g. use `yocto` to generate a toolchain)


While this chapter primarily focuses on employing the second method for creating a toolchain, it also includes a segment discussing the downloading of prebuilt toolchains.

**Before Getting Start**

it is required to use A Linux-based host system (e.g. Ubuntu) with *autoconf, automake, bison, bzip2, cmake, flex, g++, gawk, gcc, gettext, git, gperf, help2man, libncurses5-dev, libstdc++6, libtool, libtool-bin, make, patch, python3-dev,rsync, texinfo, unzip, wget, and xz-utils* or their equivalents installed.

if you have Ubuntu (or any other distribution that uses apt package manager) execute the following command:
```bash
sudo apt-get install autoconf automake bison bzip2 cmake  flex g++ gawk gcc gettext git gperf help2man libncurses5-dev libstdc++6 libtool libtool-bin make patch python3-dev rsync texinfo unzip wget xz-utils
```

if you don't have the beaglebone black you can use the Qemu emulator

## 1- Introduction
 toolchain is a set of distinct software development tools that are linked (or chained) together by specific stages such as GCC, binutils, and glibc. Optionally, a toolchain may contain other tools such as a debugger or a compiler for a specific programming language, such as C++.<br>

**Versions of Toolchains**

* GNU toolchain

    The most used toolchain for Linux, and has the advantage of compatibility with the existing code base and support for a wide range of architectures and operating systems

* Clang compiler and the associated Low Level Virtual Machine (LLVM) project

    over the past few years, have progressed to the point that it is now a viable alternative to a GNU toolchain One major distinction between LLVM and GNU-based toolchains is the licensing; LLVM has a BSD license while GNU has the GPL. it is also faster than GNU in compilation and better diagnostics

### 1.1 Toolchain components
![toolchainblock diagram](https://i.ibb.co/Lzm3wrS/toolchain.jpg)


a standard toolchain consists of the following:

1- **Binutils**<br>
GNU Binutils is the first component of a toolchain. The GNU Binutils contains two very important tools:


* `as`, the assembler, that turns assembly code (generated by GCC) into binary
* `ld`, the linker, that links several object codes into a library, or an executable (discussed in the prerequisites chapter)

Binutils also contains a couple of other binary file manipulation or analysis tools, such as `objcopy`, `objdump`, `nm`, `readelf`, `strip`, and so on. The Binutils [website](https://sourceware.org/binutils/docs-2.19/) has some documentation on all these tools. 

2- **Compilers**<br>
in GNU toolchains we have GNU Compiler Collection (GCC), which are the compilers for C and other languages, which, depending on the version of GCC, include 
* C++
* Objective-C,
* Objective-C++
* Java
* Fortran
* Ada
* Go

They all use a common backend (the phases of the compiler that  that produces assembler code), which is fed to the GNU assembler.

3- **C library**

C library implements the standardized application program interface (API) POSIX specification, which is the main interface to the operating system and provides higher-level services. (see additional information section for more about API and interfaces []()), it will be discussed further in this section.


* glibc 

    GNU C-Library is the C library from the GNU project. It's the C library used by virtually all desktop and server GNU/Linux systems. It's feature-full, portable, and complies to standards, but a bit bloated

    * Embedded GLIBC (EGLIBC)

        It is a variant of the GNU C Library (GLIBC) optimized for embedded systems. Its goals include reduced footprint and support for cross-compiling and cross-testing while maintaining source and binary compatibility with GLIBC. The project is discontinued.

* uClibc

    microcontroller C library is an alternate C library, which as its name suggests features a much smaller footprint. This library can be an interesting alternative if flash space and/or memory footprint are an issue. However, the space advantages gained using uClibc are becoming less important as the price of memory and flash continues to drop. It is still a useful C library for embedded systems without an MMU.

    * uClibc-ng 

         a spin-off/fork of the uClibc C library. The main goal of the spin-off is to do regular releases and do a lot of automatic runtime testing.

* musl

    New standard C library. musl is lightweight, fast, simple, free, and strives to be correct in the sense of standards-conformance and safety.

The C library has a special relation with the C compiler, so the choice of the C library must be made when the toolchain is generated. Once the toolchain has been built, it is no longer possible to switch to another library. 

4- **Debugger**

Most people would consider the GNU Debugger (GDB) to be part of the toolchain as well, In the embedded Linux world, the typical debugger is GDB. 

5- **Linux Kernel Headers**
    
Kernel headers are necessary for the C Library to compile functions that directly access the kernel. The usage of kernel headers extends beyond the C library; certain programs that interact directly with the kernel also require inclusion of kernel headers, such as those involved in drawing graphics on Linux frame buffers.

> Note: Linux kernel headers are version-specific. For instance, if a program is compiled against kernel version 4.19, it may not function properly on newer kernel versions like 6.6, but it should be compatible with older kernel versions due to backward compatibility support

### 1.2 Target of a toolchain
as mentioned toolchains take the program code as input and translate it to equivalent assembly code which depends on the processor. This produced code will most likely depend on various calls to the operating system (e.g. to allocate dynamic memory), and have a header defining properties of the assembly file (e.g. the location of the code and data sections) (e.g. ELF, PE). An assembler then compiles this assembly to object files, which are linked using the linker of this platform. Hence All these tools produce code for a specific architecture and OS.

so a toolchain is specified towards a specific target which mainly depends on the processor architecture and the host operating system. hence if a developer builds an application with the toolchain on his machine (for example Linux on x86_64), if he tries to move this program to a different system (e.g. Windows on x86_64), the program will not work as it was linked via Linux Linker against Linux defined system call which isn't the same as windows. the same result will happen if the developer moves the program from Linux on x86_64 to Linux on arm64 (Raspberry Pi for example). 

This does not mean that the compiler and linker cannot run on another type of system. The process of compiling code for another system is called cross-compiling. Then we have two types of toolchains:

**Types of toolchains**

* Native: 

    This toolchain runs on a system to generate programs for the same type of system that it runs on (e.g. compiling a program on Linux to run on the same machine). This is the usual case for desktops and servers, and it is becoming popular on certain classes of embedded devices. The Raspberry Pi running Debian for ARM, for example, has self-hosted native compilers

* Cross:

    This toolchain runs on a different type of system than the target, where it runs on a system to output an executable for another target (hence its name cross) allowing the development to be done on a fast desktop PC and then loaded onto the embedded target for testing and running (e.g. compiling a program on Linux on x86_64 to run on raspberry pi)

Almost all embedded Linux development is done using a cross-development toolchain, partly because most embedded devices are not well suited to program development since they lack computing power, memory, and storage, but also because it keeps the host and target environments separate. to imply the principle of keeping the toolchain for the target consistent throughout the life of the project.

**what if the target and the host have the same architecture and OS, x86_64 Linux, for example?**

In this case, the native toolchain on the host can build an executable that can be executed on the host and on the target, however, This works up to a point until the host distribution will receive updates more often than the target, or that different engineers building code for the target will have slightly different versions of the host development libraries.

Over time, as this sperate continues changing the development and target systems will not be the same, and the principle that the toolchain should remain constant throughout the life of the project will be violated. 
This approach can work if the host and the target build environments are in lockstep with each other. However, a much better approach is to keep the host and the target separate, and a cross-toolchain is the way to do that.

However, cross-development is not always simple because many open-source packages are not designed to be built in this way. hence in case of compiling a large number of additional packages, it is better to natively compile them. For example, building a Debian distribution for the Raspberry Pi or BeagleBone using a cross-compiler would be very hard. Instead, they are natively compiled.


### 1.3 CPU architectures and toolchain names

the toolchain has to be built according to the all capabilities of the target CPU not only the CPU architecture os the following points are the capabilities of a CPU that a toolchain has to be built according to:

• **CPU architecture**: ARM, Microprocessor without Interlocked Pipelined Stages (MIPS), x86_64, and so on

• **Big- or little-endian operation**: Some CPUs can operate in both modes, but the machine code is different for each

• **Floating point support**: Not all versions of embedded processors implement a hardware floating-point unit, in which case the toolchain has to be configured to call a software floating-point library instead

• **Application Binary Interface (ABI)**: The calling convention used for passing parameters between function calls at the binary level and (see [ABI](#10.3--applicationbinaryinterface) in the additional information section) 

With many architectures, the ABI is constant across the family of processors. One notable exception is ARM. The ARM architecture transitioned to the Extended Application Binary Interface (EABI) in the late 2000s, resulting in the previous ABI being named the Old Application Binary Interface (OABI).

While the OABI is now obsolete, you'll continue to see references to EABI. Since then, the EABI has split into two, based on the way the floating-point parameters are passed:
* The original EABI uses general-purpose (integer) registers 
* the newer Extended Application Binary Interface Hard-Float (EABIHF) uses a floating point register

The *EABIHF* is significantly faster at floating-point operations since it removes the need for copying between integer and floating-point registers, but it is not compatible with CPUs that do not have a floating-point unit. The choice, then, is between two incompatible ABIs; you cannot mix and match the two, and so you have to decide at this stage.

**GNU Tools name in GNU Toolchain**

GNU uses prefixes for every tool, so it can give information about which target(OS and architecture) this toolchain compiles for. this prefix consists of 3 or 4 parts separated by dashes indicating the CPU architecture Vendor, OS, and ABI.
```
<arch>-<vendor>-<OS>-<abi>
```
to get the the toolchain tool name without navigating to its directory execute the following command:
```bash
gcc --dumpmachine
```
on Linux, the result is:
```bash
x86_64-linux-gnu
```
on Windows, the result is:
```bash
x86_64-w64-mingw32
```
as mentioned before and shown and the name consists of the following parts:
* CPU architecture: `x86_64` on both machines
* vendor: it is optional as in the two cases above, but its value may be buildroot, poky, or just unknown
* Operating System: the kernel of the OS `Linux` and `w64`
* ABI: for Linux is `gnu` and for Windows is MinGW - Minimalist GNU for Windows `mingw32`

a detailed description of ABI is available in the additional information section below.


### 1.4 The C-library
previously mentioned the available C libraries, in this section the function of a C Library and the criteria for choosing it will be explained.

consider the following example, a simple C program to open a file
```c
#include <stdio.h>
int main() {
 FILE *file;
    char filename[] = "example.txt";
 file = fopen(filename, "r");
    fclose(file);
    return 0;
}
```
a very simple function that is independent of OS, which is responsible for managing files. but how is it possible for this simple function to open a file independent of OS with this simplicity?  the answer is in the C library. The function ` fopen(filename, "r");` is implemented in C-Library to do the process of opening a file in the target OS. 

In this example Linux is used; the request to the Linux kernel to open a file and return it is performed in certain steps with defined inputs and outputs to/from the kernel (see steps in POSIX subsection in the additional information section). But if every operating system defines its steps and input/output for such an operation it will be a headache to write a library for every OS to be compatible with.

fortunately, a family of OS implements common standards called the Portable Operating System Interface standards (POSIX standards) such as Linux, Mac, QNX, and others which standardize the steps and process of communication between applications (called user-space) and the kernel (kernel space) via a common system call, all of these new terms will be discussed in another chapter.

![c library block diagram](https://i.ibb.co/4Jqs1JV/Untitled-1.jpg)
from the graph, it is clear that a program can make the system call and request from the kernel directly but it will make the program more complex and reinvent the wheel.

finally, we can say that
> A C Library is **an implementation of interface between programs and kernel**.

it is not only limited to C language, other languages like Java and Python are linked with libraries that use the C library for providing runtime support and calling OS functions. 

different C libraries were mentioned previously, in the following section is a comparison between them and the criteria for choosing them.

#### Choosing C libraries
* **glibc**: it is very big and the most complete implementation of POSIX
* **musl**: a newer and smaller alternative for glibc, used when the target has limited memory
* **uClibc-ng**: it was developed for a Linux distro that can work without MMu (an OS requires MMU), this distro is called microcontroller Linux (uCLinux). until it has been adopted to support full Linux. the ng postfix means a new generation of the original library uClibc which faces issues in its functionality
* **eglibc**: embedded glibc; an optimized version of glibc for microcontroller and added support for some architectures that weren't supported by glibc like PowerPC e500 CPU. however, it is now obsolete and its code is merged back to glibc

now after discussing every library, **it is recommended to use glibc** unless:
* you are using uCLinux, the best choice for it is to use uClibc-ng
* you are using a target with limited resources, the best choice for it is to use musl

> Note: not all pre-built toolchains support all C libraries


## 2. Finding a toolchain

as previously mentioned, methods for getting a toolchain are:
* use pre-built toolchains
* build it with your customization, or use a tool to build it
* use buildsystems to generate one

### 2.1 Pre-built toolchains
for a pre-built toolchain is an easy solution, but here are some considerations you should make:
* does the toolchain support the required C library?
* does the toolchain support the target hardware and processor architecture?
* does the toolchain support the target ABI?
* does the toolchain size fit your requirements?
* Is it updated with the latest security requirements and bug fixes?
* does it contain the latest kernel headers version for Linux?

if your answer is no for any of these you should search for another pre-built toolchain, which is considered a daunting task, especially in customizing Linux for unpopular boards.

however, some entities provide pre-built toolchains like:

* SOC vendors
* A third-party Linux tool vendor
* an alliance dedicated to providing system-level support for a given architecture. For example, Linaro for the ARM architecture
* generated toolchains from build systems such as provided by [yocto](https://downloads.yoctoproject.org/releases/yocto/yocto-5.0.1/toolchain/)

here are some resources from [elinux](https://elinux.org/Toolchains#Prebuilt_toolchains):

1. **Bootlin**<br/>
Since June 2017, Bootlin has been offering free pre-built toolchains on [toolchains.bootlin.com](http://toolchains.bootlin.com/), supporting more than 38 CPU architecture variants, and three C libraries: GNU libc, uClibc-ng, and musl.

2. **CodeSourcery**<br/>
[CodeSourcery](http://www.codesourcery.com/) is used to release free cross-compiling toolchains for the major embedded architectures.

3. **Linaro (ARM)**<br/>
[Linaro](https://wiki.linaro.org/WorkingGroups/ToolChain) releases optimized toolchains for recent ARM CPUs (Cortex A8, A9...). These include Linaro's latest contributions to mainline GCC but backported to stable GCC versions for immediate use by product developers. Linaro hires CodeSourcery people to improve ARM toolchains, so the ARM toolchains that you get with Linaro should be at least as good as the CodeSourcery ones.

 Native toolchains are available through the standard GCC toolchain in Ubuntu. Cross toolchains from Linaro are available to Ubuntu users through special packages:

```bash
sudo add-apt-repository ppa:linaro-maintainers/toolchain
sudo apt-get install gcc-arm-linux-gnueabi
```

Now find out the path and name of the cross-compiler executable by looking at the contents of the package:

 `dpkg -L gcc-arm-linux-gnueabi`

Arch Linux users can install:
```bash
yaourt -S gcc-linaro-arm-linux-gnueabihf
```


4. **musl.cc**<br/>

 [musl.cc](https://musl.cc/) provides static, musl-based cross- and native- GCC toolchains targeting various Linux- and Windows-based platforms. Toolchains run on Linux, macOS, Windows, and Solaris. Please note that this is a community-run website and is not officially endorsed by the musl project or its authors.

[find more](https://elinux.org/Toolchains#Prebuilt_toolchains)


### 2.2 Customized toolchains

toolchains are a series of programs and libraries that can be built, but building a toolchain from scratch is not an easy task. you read about it from [cross Linux from scratch](https://trac.clfs.org/). however, there is a tool that encapsulates make files and scripts for building toolchains and lets the user configure these scripts and make files to customize the output toolchain via a menu interface or by choosing from samples to build a toolchain. this tool is called **Crosstool-ng**. 

## 3. Building a toolchain using crosstool-NG
in this section, a toolchain is created for beaglebone black and Qemu. this section may be grouped with other sections from different articles into a separate article that shows the practical steps for customization of an image for Qemu and beaglebone black.

### 3.1 History of crosstool and crosstool-NG
building, updating, and maintaining a toolchain from scratch is a hard task. for that, on the community of the cross-compiler, the developers are uploading their scripts trying to automate some tasks of building and testing a toolchain. a programmer was responsible for the maintenance of a toolchain in his work and was searching for a solution for automating his process. he collected the scripts and made files from the community and added some advanced features including support for newer versions of toolchains and the ability to automate testing and created a standalone tool that automates the generation of toolchain and he called it the **crosstool**, his name is Dan Kegel you can read about his full story from [here](http://kegel.com/crosstool/).

the crosstool didn't support the generation of all compilers, so in late 2007 Yann E. Morin added the support for uClibc and other features including a menu interface that makes users do the configuration via a menu and called this the new generation of the toolchain, or **crosstool-NG**, read about the full story from [here](https://crosstool-ng.github.io/docs/introduction/) or visit their [website](https://crosstool-ng.github.io/).


### 3.2 Downloading and Installing crosstool-NG

before downloading and installing crosstool-NG, you should install the tools stated at the beginning of the section.

1. create a directory for the crosstool-NG
2. fetch the latest version crosstool-NG (at writing of this article it is 1.26.0) 
3. install and config the crosstool-NG

you can get the crosstool-NG as tarball from [here](http://crosstool-ng.org/download/crosstool-ng/) or by using command `wget` as follows:
```bash
wget http://crosstool-ng.org/download/crosstool-ng/crosstool-ng-VERSION.tar.bz2
```
Note: replace the -VERSION with the required version number, as in this case the latest version is 1.26.0, then

```bash
ziad@ziadpc:~$ wget http://crosstool-ng.org/download/crosstool-ng/crosstool-ng-1.26.0.tar.bz2
```

or clone the github repository and checkout to the latest version, note the default branch is the dev branch which is might be unstable. in this chapter this method is used.

```bash
ziad@ziadpc:~$ mkdir toolchain_playground && cd toolchain_playground

ziad@ziadpc:~/toolchain_playground$ git clone https://github.com/crosstool-ng/crosstool-ng.git #download the unstable development branch
ziad@ziadpc:~/toolchain_playground$ cd crosstool-ng
ziad@ziadpc:~/toolchain_playground$ git checkout crosstool-ng-1.26.0 #download the stable release branch
```
for running configuration and installation, navigate to the  execute the following commands from the `crosstool-ng` directory:
```bash
./bootstrap
./configure --prefix=${PWD} --enable-local #run the configure script
make
make install #in case of failure run with sudo make install 
```

The --prefix=${PWD} option means that the program will be installed into the current directory, which avoids the need for root permissions, as would be required if you were to
install it in the default location /usr/local/share.

now crosstool-ng is installed, next we will build toolchain for beaglebone black.

### 3.3 Building a toolchain for BeagleBone Black
for configuration of the toolchain for BeagleBone we can launch the menu to configure the output, however we can use samples to generate the toolchain. 

to list samples
```bash
./ct-ng list-samples
```
example:
```bash
ziad@ziadpc:~/toolchain_playground/crosstool-ng$ ./ct-ng list-samples
Status  Sample name
[L...]   aarch64-ol7u9-linux-gnu
[L...]   aarch64-ol8u6-linux-gnu
[L...]   aarch64-ol8u7-linux-gnu
[L...]   aarch64-rpi3-linux-gnu
[L...]   aarch64-rpi4-linux-gnu
[L...]   aarch64-unknown-linux-gnu
[L...]   aarch64-unknown-linux-uclibc
[L...]   alphaev56-unknown-linux-gnu
....
# the rest of the output is left over
....
 L (Local)       : sample was found in current directory
 G (Global)      : sample was installed with crosstool-NG
 X (EXPERIMENTAL): sample may use EXPERIMENTAL features
 B (BROKEN)      : sample is currently broken
 O (OBSOLETE)    : sample needs to be upgraded

```
for example we can select the configuration of `aarch64-ol7u9-linux-gnu`, to set the configuration execute the following:
```bash
ziad@ziadpc:~/toolchain_playground/crosstool-ng$ ./ct-ng aarch64-ol7u9-linux-gnu

CONF  aarch64-ol7u9-linux-gnu
#
# configuration written to .config
#

***********************************************************

Initially reported by: Jose E. Marchesi
URL: 

Comment:
OL 7.9 toolchain configured for AARCH64

***********************************************************

Now configured for "aarch64-ol7u9-linux-gnu"
ziad@ziadpc:~/toolchain_playground/crosstool-ng$ 
```
now we can launch the menu configuration and see the preconfiured values
```bash
ziad@ziadpc:~/toolchain_playground/crosstool-ng$ ./ct-ng menuconfig
```
![menuconfig](https://i.ibb.co/TL3dXcG/Screenshot-from-2024-06-10-18-22-27.png)

then, we can search for the toolchain configuration sample that fits beaglebone black to save time without manually setting the configuration from the menu.

recalling the name of a toolchain:
```
<arch>-<vendor>-<os>-<abi>
```
after searching about beaglebone black on their website, we will found that it utilizes **AM335x 720MHz ARM Cortex-A8** processor. 
so for architecture: we found that it is ARM. now we will search about its floating point processor.

after searching on ARM website, we found that this processor has a floating point processor.
![arm processor](https://developer.arm.com/-/jssmedia/Arm%20Developer%20Community/Images/Block%20Diagrams/Cortex-A%20Processor/Cortex-A8.png?h=311&iar=0&w=325&rev=d7eb2bd926f24f35b0adf7e96172b39a&hash=FD003080F18279ED87091C45BCA35AFB)

for decding the C-library to use, beaglebone supports booting from SD card, so memory size isn't a problem, hence we can use glibc as the selected library.

now we will search for the configuration that best fit our requirements:

```bash
ziad@ziadpc:~/toolchain_playground/crosstool-ng$ ./ct-ng list-samples | grep arm-cortex
[L...]   arm-cortex_a15-linux-gnueabihf
[L..X]   arm-cortexa5-linux-uclibcgnueabihf
[L...]   arm-cortex_a8-linux-gnueabi
[L..X]   arm-cortexa9_neon-linux-gnueabihf
[L..X]   x86_64-w64-mingw32,arm-cortexa9_neon-linux-gnueabihf
```

the best configuration to fit our requirements is ` arm-cortex_a8-linux-gnueabi`, except its abi not supports hard float (`gnueabi` should be `gnueabiHF`), then here is the power of customization that we can select this sample and modify it via menu configuration to use `gnueabihf`.

**1. Find the complete details about this sample**
```bash
 ./ct-ng show-[sample name]
```
```bash
ziad@ziadpc:~/toolchain_playground/crosstool-ng$ ./ct-ng show-arm-cortex_a8-linux-gnueabi
[L...]   arm-cortex_a8-linux-gnueabi
    Languages       : C,C++
    OS              : linux-6.4
    Binutils        : binutils-2.40
    Compiler        : gcc-13.2.0
    C library       : glibc-2.38
    Debug tools     : duma-2_5_21 gdb-13.2 ltrace-0.7.3 strace-6.4
    Companion libs  : expat-2.5.0 gettext-0.21 gmp-6.2.1 isl-0.26 libelf-0.8.13 libiconv-1.16 mpc-1.2.1 mpfr-4.2.1 ncurses-6.4 zlib-1.2.13 zstd-1.5.5
    Companion tools :
```

**2. Set the sample configuration**

```
./ct-ng arm-cortex_a8-linux-gnueabi
```

```bash
ziad@ziadpc:~/toolchain_playground/crosstool-ng$ ./ct-ng arm-cortex_a8-linux-gnueabi

CONF  arm-cortex_a8-linux-gnueabi
#
# configuration written to .config
#

***********************************************************

Initially reported by: Yann E. MORIN
URL: http://ymorin.is-a-geek.org/

***********************************************************

Now configured for "arm-cortex_a8-linux-gnueabi"
```

**3- Decide which configuration you want to change in the menu config**

1- enable support for hardware floating point

2- use neon as specific FPU **to BUILD THE LINUX KERNEL successfully**

3- enable the toolchain to be linked with new libraries after built

```bash
ziad@ziadpc:~/toolchain_playground/crosstool-ng$ ./ct-ng menuconfig
```

1- enable support for hardware floating point
* navigate to **Target options** (press enter on it)
* in target options navigate to **Floating Point**(press enter on it)
* in floating point menu choose **hardware (FPU)** then press enter

2- use neon as specific FPU 
* in target options menu navigate to **Use specific FPU**
* write **neon** and press enter

3- enable the toolchain to be linked with new libraries after built
* in the main menu navigate to **Paths and misc options** menu
* navigate to **Render the toolchain read-only** and disable it (it shouldn't start with an asterisk)

finally choose save in the bottom menu, then exit.now we can build our beaglebone black toolchain

> NOTE: you can search for settings and their current value  by pressing `/` in the menuconfig

after getting back to the terminal, type the following to build the toolchain.
```bash
./ct-ng build
```

```bash
iad@ziadpc:~/toolchain_playground/crosstool-ng$ ./ct-ng build
[INFO ]  Performing some trivial sanity checks
[WARN ]  Number of open files 1024 may not be sufficient to build the toolchain; increasing to 2048
[INFO ]  Build started 20240610.190437
[INFO ]  Building environment variables
[WARN ]  Directory '/home/ziad/src' does not exist.
[WARN ]  Will not save downloaded tarballs to local storage.
[EXTRA]  Preparing working directories
[EXTRA]  Installing user-supplied crosstool-NG configuration
[EXTRA]  =================================================================
[EXTRA]  Dumping internal crosstool-NG configuration
[EXTRA]    Building a toolchain for:
[EXTRA]      build  = x86_64-pc-linux-gnu
[EXTRA]      host   = x86_64-pc-linux-gnu
[EXTRA]      target = arm-cortex_a8-linux-gnueabihf
[EXTRA]  Dumping internal crosstool-NG configuration: done in 0.39s (at 00:06)
[INFO ]  =================================================================
[INFO ]  Retrieving needed toolchain components' tarballs
[EXTRA]    Retrieving 'linux-6.4'
.....
```

<br>

**THE OUTPUT :**

> **Find the build output in ~/x-tools/arm-cortex_a8-linux-gnueabihf**


### 3.4 Building a toolchain for Qemu







## 10- Additional Information
### 10.1- POSIX
POSIX is a family of standards specified by the IEEE for maintaining compatibility between operating systems.POSIX defines both the system and user-level **application programming interfaces** (APIs), along with command line shells and utility interfaces.

**What does Standardization of POSIX provide?** 

when compiling a program that follows the standards of POSIX, it became compatible with every OS that implements the POSIX, since these OSes follow the same standard. Here are some features of using Standardization (especially POSIX): 
1. **Standardization between different UNIX-based** systems, as programs compiled for one of the UNIX-based systems can run on one another without modification

2. **The standardization between command line** utilities, as commands like `ls`,`cp`, and `grep` make them compatible with any Unix-based system 
3. **The standardization of a** command language for writing shell scripts, make scripts can be run on any POSIX-compliant system without modification.

**OSes that implement POSIX**
Many operating systems aim to be POSIX-compliant, including most UNIX variants (like BSD, AIX, HP-UX) and UNIX-like systems (like Linux and macOS). While Windows is not POSIX-compliant by default, there are subsystems and compatibility layers, like Windows Subsystem for Linux (WSL), that provide POSIX-like environments.

**Example of using POSIX**
consider a C-program that reads and writes from/to a file in Linux

```c
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>

#define FILENAME "helloworld.txt"

int main() {
    int fd;
    char buffer[256];
    const char *message = "Hello, World!\n";

    // Open the file for writing (create if it doesn't exist, truncate if it does)
    //O_WRONLY | O_CREAT | O_TRUNC -> File operations
 fd = open(FILENAME, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd == -1) {
        perror("Failed to open file");
        return 1;
 }

    // Write the message to the file
    if (write(fd, message, strlen(message)) == -1) {
        perror("Failed to write to file");
        close(fd);
        return 1;
 }
   

    // Read the content from the file
    ssize_t bytesRead = read(fd, buffer, sizeof(buffer) - 1);
    if (bytesRead == -1) {
        perror("Failed to read from file");
        close(fd);
        return 1;
 }

    // Null-terminate the buffer and print it
    buffer[bytesRead] = '\0';
    printf("Read from file: %s", buffer);

    // Close the file
    if (close(fd) == -1) {
        perror("Failed to close file");
        return 1;
 }

    return 0;
}

```

The functions of `open`, `write`, `read`, and `close` communicates with the OS via **system call** (will be discussed in another chapter), but it can be considered as the interface between the applications and the OS, this system call implements the POSIX standard, hence the application can communicate with OS(Linux).

The steps of opening a file that is abstracted by the `open` function are:

1. the **program** calls `fopen()` from **C Library** and prepares the file (specifying the file name and file operation)
2. the **C Library** makes a system call to the OS
3. the **OS** opens the file and returns a file descriptor to the **C Library**. This file descriptor is an integer representing the opened file
4. the **C Library** represents the returned file descriptor with the defined `FILE` structure
5. the **C Library** creates a pointer to this structure and returns it to the calling **program**, in case of failure to open a file, the C library handles this issue by returning a NULL pointer



### 10.2 -API and interfaces
a good brief explanation of Interfaces and API on [Stack overflow](https://stackoverflow.com/questions/2171177/what-is-an-application-binary-interface-abi) states the following:

**Interface**: <br>It is an "existing entity" layer between the functionality and consumer of that functionality. An interface by itself doesn't do anything. It just invokes the functionality lying behind.

for example:

>A TV remote is an interface between the user and the TV. It is an existing entity, but useless (doesn't provide any functionality) by itself. All the functionality for each of those buttons on the remote is implemented in the television set.

another example that defines the user and the interface type.

* Command Line Interface (CLI):

 commands are the existing entities, the consumer is the user and functionality lies behind them.

 functionality: my software functionality which solves some purpose to which we are describing this interface.

 existing entities: commands

 consumer: user

* Graphical User Interface(GUI):
 
 window, buttons, etc. are the existing entities, and again the consumer is the user and functionality lies behind.

 functionality: my software functionality which solves some problems to which we are describing this interface.

 existing entities: windows, buttons, etc.

 consumer: user

* Application Programming Interface(API) 

 functions are the existing entities (and interfaces in languages that support OOP classes, objects, interfaces, ...etc), the consumer here is another program, not a user, and again functionality lies behind this layer.

 functionality: my software functionality which solves some problems to which we are describing this interface.

 existing entities: functions, Interfaces (array of functions).

 consumer: another program/application.

### 10.3- Application binary interface
 The ABI defines the structures and methods that your compiled application will use to access the external library, hence we can say that:
 for ABI:
  
 functionality: the software functionality in libraries or operating systems at the binary level.

 existing entities: functions, Interfaces (array of functions), and some standards for accessing data at the binary level.

 consumer: another program/application at the binary level.

hence it can be said that the ABI is the compiled version of API, also ABI is responsible for defining the following:

* Processor instruction set, with details like register file structure, stack organization, memory access types, etc
* Sizes, layouts, and alignments of basic data types that the processor can directly access
* Calling (e.g. of function) convention, which controls how the arguments of functions are passed, and return values retrieved; for example, it controls the following:
    * Whether all parameters are passed on the stack, or some are passed in registers
    * Which registers are used for which function parameters
    * Whether the first function parameter passed on the stack is pushed first or last
    * Whether the caller or callee is responsible for cleaning up the stack after the function call
* How an application should make system calls to the operating system
* In the case of a complete operating system ABI, the binary format of object files, program libraries, etc.

ABIs are important when it comes to applications that use external libraries. Libraries are full of code and other resources, but your program has to know how to locate what it needs inside the library file. Your ABI defines how the contents of a library are stored inside the file, and your program uses the ABI to search through the file and find what it needs. If everything in your system conforms to the same ABI, then any program can work with any library file, no matter who created it. Linux and Windows use different ABIs, so a Windows program won't know how to access a library compiled for Linux, for example, the extension of Linux shared libraries is `.so` while for Windows is `.dll`